// The MIT License (MIT)
// Â© mihakralj
//@version=6

//@library Library of reversal and pivot point detection indicators
library("reversals")

//@function Calculates Parabolic Stop And Reverse (SAR)
//@param af_start Initial acceleration factor (Wilder's original: 0.02)
//@param af_increment Acceleration factor increment per new extreme (Wilder's original: 0.02)
//@param af_max Maximum acceleration factor (Wilder's original: 0.20)
//@returns SAR value (stop level for current trend)
export psar(simple float af_start=0.02, simple float af_increment=0.02, simple float af_max=0.20) =>
    if af_start <= 0 or af_start > af_max
        runtime.error("Start AF must be > 0 and <= Max AF")
    if af_increment <= 0
        runtime.error("AF increment must be > 0")
    if af_max <= af_start
        runtime.error("Max AF must be > Start AF")
    var bool is_long = true
    var float sar = low
    var float ep = high
    var float af = af_start
    if bar_index == 0
        is_long := close > open
        sar := is_long ? low : high
        ep := is_long ? high : low
        af := af_start
    else
        float new_sar = sar + af * (ep - sar)
        bool reverse = false
        if is_long
            new_sar := math.min(new_sar, low[1])
            if bar_index > 1
                new_sar := math.min(new_sar, low[2])
            if low < new_sar
                reverse := true
                is_long := false
                new_sar := ep
                ep := low
                af := af_start
            else
                if high > ep
                    ep := high
                    af := math.min(af + af_increment, af_max)
        else
            new_sar := math.max(new_sar, high[1])
            if bar_index > 1
                new_sar := math.max(new_sar, high[2])
            if high > new_sar
                reverse := true
                is_long := true
                new_sar := ep
                ep := high
                af := af_start
            else
                if low < ep
                    ep := low
                    af := math.min(af + af_increment, af_max)
        sar := new_sar
    sar

//@function Detects Williams Fractal patterns (5-bar pattern)
//@returns Tuple [up_fractal, down_fractal] with fractal values (na if no fractal)
export fractals() =>
    bool is_up_fractal = false
    bool is_down_fractal = false
    if bar_index >= 4
        is_up_fractal := high[2] > high[4] and high[2] > high[3] and high[2] > high[1] and high[2] > high[0]
        is_down_fractal := low[2] < low[4] and low[2] < low[3] and low[2] < low[1] and low[2] < low[0]
    float up_fractal_value = is_up_fractal ? high[2] : na
    float down_fractal_value = is_down_fractal ? low[2] : na
    [up_fractal_value, down_fractal_value]

//@function Detects swing highs and swing lows using lookback period
//@param lookback Number of bars on each side to confirm swing point
//@param source_high Price series for swing high detection (typically high)
//@param source_low Price series for swing low detection (typically low)
//@returns Tuple [swing_high, swing_low] with swing point values (na if no swing)
export swings(simple int lookback, series float source_high, series float source_low) =>
    if lookback <= 0
        runtime.error("Lookback must be greater than 0")
    if lookback > 100
        runtime.error("Lookback exceeds maximum of 100")
    bool is_swing_high = true
    bool is_swing_low = true
    if bar_index < lookback * 2
        is_swing_high := false
        is_swing_low := false
    else
        float center_high = source_high[lookback]
        float center_low = source_low[lookback]
        for i = 1 to lookback
            if source_high[lookback - i] > center_high or source_high[lookback + i] > center_high
                is_swing_high := false
            if source_low[lookback - i] < center_low or source_low[lookback + i] < center_low
                is_swing_low := false
    float swing_high_value = is_swing_high ? source_high[lookback] : na
    float swing_low_value = is_swing_low ? source_low[lookback] : na
    [swing_high_value, swing_low_value]

//@function Calculates classic/standard/floor pivot points
//@param tf Timeframe for pivot calculation ("D", "W", "M")
//@returns Tuple [pp, r1, r2, r3, s1, s2, s3] with pivot levels
export pivot(simple string tf) =>
    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    if na(hi) or na(lo) or na(cl)
        [na, na, na, na, na, na, na]
    else
        float pp = (hi + lo + cl) / 3.0
        float r1 = 2.0 * pp - lo
        float s1 = 2.0 * pp - hi
        float r2 = pp + (hi - lo)
        float s2 = pp - (hi - lo)
        float r3 = hi + 2.0 * (pp - lo)
        float s3 = lo - 2.0 * (hi - pp)
        [pp, r1, r2, r3, s1, s2, s3]

//@function Calculates Camarilla pivot points with 8 levels for short-term trading
//@param tf Timeframe for pivot calculation ("D", "W", "M")
//@returns Tuple [pp, r1, r2, r3, r4, s1, s2, s3, s4] with pivot levels
export pivotcam(simple string tf) =>
    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    if na(hi) or na(lo) or na(cl)
        [na, na, na, na, na, na, na, na, na]
    else
        float pp = (hi + lo + cl) / 3.0
        float hl_range = hi - lo
        float r1 = cl + hl_range * 1.0833 / 12.0
        float s1 = cl - hl_range * 1.0833 / 12.0
        float r2 = cl + hl_range * 1.1666 / 12.0
        float s2 = cl - hl_range * 1.1666 / 12.0
        float r3 = cl + hl_range * 1.2500 / 12.0
        float s3 = cl - hl_range * 1.2500 / 12.0
        float r4 = cl + hl_range * 1.5000 / 12.0
        float s4 = cl - hl_range * 1.5000 / 12.0
        [pp, r1, r2, r3, r4, s1, s2, s3, s4]

//@function Calculates DeMark pivot points with conditional open/close logic
//@param tf Timeframe for pivot calculation ("D", "W", "M")
//@returns Tuple [pp, r1, s1] with pivot levels (only 3 levels)
export pivotdem(simple string tf) =>
    [hi, lo, op, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], open[1], close[1]], lookahead=barmerge.lookahead_on)
    if na(hi) or na(lo) or na(op) or na(cl)
        [na, na, na]
    else
        float x = 0.0
        if cl < op
            x := hi + 2.0 * lo + cl
        else if cl > op
            x := 2.0 * hi + lo + cl
        else
            x := hi + lo + 2.0 * cl
        float pp = x / 4.0
        float r1 = x / 2.0 - lo
        float s1 = x / 2.0 - hi
        [pp, r1, s1]

//@function Calculates extended traditional pivot points with R4-R5 and S4-S5 levels
//@param tf Timeframe for pivot calculation ("D", "W", "M")
//@returns Tuple [pp, r1, r2, r3, r4, r5, s1, s2, s3, s4, s5] with pivot levels
export pivotext(simple string tf) =>
    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    if na(hi) or na(lo) or na(cl)
        [na, na, na, na, na, na, na, na, na, na, na]
    else
        float pp = (hi + lo + cl) / 3.0
        float hl_range = hi - lo
        float r1 = 2.0 * pp - lo
        float s1 = 2.0 * pp - hi
        float r2 = pp + hl_range
        float s2 = pp - hl_range
        float r3 = hi + 2.0 * (pp - lo)
        float s3 = lo - 2.0 * (hi - pp)
        float r4 = hi + 3.0 * (pp - lo)
        float s4 = lo - 3.0 * (hi - pp)
        float r5 = hi + 4.0 * (pp - lo)
        float s5 = lo - 4.0 * (hi - pp)
        [pp, r1, r2, r3, r4, r5, s1, s2, s3, s4, s5]

//@function Calculates Fibonacci pivot points using Fibonacci ratios
//@param tf Timeframe for pivot calculation ("D", "W", "M")
//@returns Tuple [pp, r1, r2, r3, s1, s2, s3] with pivot levels
export pivotfib(simple string tf) =>
    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    if na(hi) or na(lo) or na(cl)
        [na, na, na, na, na, na, na]
    else
        float pp = (hi + lo + cl) / 3.0
        float hl_range = hi - lo
        float r1 = pp + 0.382 * hl_range
        float s1 = pp - 0.382 * hl_range
        float r2 = pp + 0.618 * hl_range
        float s2 = pp - 0.618 * hl_range
        float r3 = pp + 1.000 * hl_range
        float s3 = pp - 1.000 * hl_range
        [pp, r1, r2, r3, s1, s2, s3]

//@function Calculates Woodie's pivot points with weighted closing price
//@param tf Timeframe for pivot calculation ("D", "W", "M")
//@returns Tuple [pp, r1, r2, r3, s1, s2, s3] with pivot levels
export pivotwood(simple string tf) =>
    [hi, lo, cl] = request.security(syminfo.tickerid, tf, [high[1], low[1], close[1]], lookahead=barmerge.lookahead_on)
    if na(hi) or na(lo) or na(cl)
        [na, na, na, na, na, na, na]
    else
        float pp = (hi + lo + 2.0 * cl) / 4.0
        float r1 = 2.0 * pp - lo
        float s1 = 2.0 * pp - hi
        float r2 = pp + (hi - lo)
        float s2 = pp - (hi - lo)
        float r3 = hi + 2.0 * (pp - lo)
        float s3 = lo - 2.0 * (hi - pp)
        [pp, r1, r2, r3, s1, s2, s3]
