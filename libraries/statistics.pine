// The MIT License (MIT)
// Â© mihakralj
//@version=6

//@library Statistics
//@description Library of 27 statistical indicators for analyzing data distributions, relationships, and properties
library("statistics")

//@function Calculates the financial Beta coefficient comparing src1 volatility to src2
//@param src1 Series to analyze
//@param src2 Benchmark series to compare against
//@param period Lookback period for calculation
//@returns Beta value showing src1 volatility relative to src2
export beta(series float src1, series float src2, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    var float last_src1 = na
    var float last_src2 = na
    src1_return = last_src1 != 0 and not na(last_src1) ? (src1 - last_src1) / last_src1 : na
    bench_return = last_src2 != 0 and not na(last_src2) ? (src2 - last_src2) / last_src2 : na
    last_src1 := src1
    last_src2 := src2
    var int count = 0
    var float sum_sr = 0.0, var float sum_br = 0.0
    var float sum_sr2 = 0.0, var float sum_br2 = 0.0
    var float sum_sbr = 0.0
    var sr_buf = array.new_float(period)
    var br_buf = array.new_float(period)
    var int index = 0
    if not na(src1_return) and not na(bench_return)
        old_sr = array.get(sr_buf, index)
        old_br = array.get(br_buf, index)
        if count >= period
            sum_sr -= old_sr, sum_br -= old_br
            sum_sr2 -= old_sr * old_sr, sum_br2 -= old_br * old_br
            sum_sbr -= old_sr * old_br
        else
            count += 1
        sum_sr += src1_return, sum_br += bench_return
        sum_sr2 += src1_return * src1_return
        sum_br2 += bench_return * bench_return
        sum_sbr += src1_return * bench_return
        array.set(sr_buf, index, src1_return)
        array.set(br_buf, index, bench_return)
        index := (index + 1) % period
    if count > 0
        mean_sr = sum_sr / count
        mean_br = sum_br / count
        cov = (sum_sbr / count) - (mean_sr * mean_br)
        var_bench = (sum_br2 / count) - (mean_br * mean_br)
        if var_bench > 1e-10
            cov / var_bench
        else
            na
    else
        na

//@function Calculates the deviation of a signal from its moving average (BIAS)
//@param src The source series
//@param len The lookback period for the SMA
//@returns The BIAS value
export bias(series float src, simple int len) =>
    if len <= 0
        runtime.error("BIAS length must be greater than 0")
    var float sma_sum = 0.0
    var float[] sma_buffer = array.new_float(len, na)
    var int sma_head = 0
    var int sma_validCount = 0
    float sma_oldestVal = array.get(sma_buffer, sma_head)
    if not na(sma_oldestVal)
        sma_sum -= sma_oldestVal
    else if not na(src)
        sma_validCount +=1
    sma_sum += nz(src, 0.0)
    array.set(sma_buffer, sma_head, src)
    sma_head := (sma_head + 1) % len
    float movingAverage = na
    if sma_validCount >= len or bar_index + 1 >= len
        movingAverage := sma_sum / math.max(sma_validCount, 1)
    if bar_index < len -1
        movingAverage := sma_sum / math.max(bar_index + 1, 1)
    float bias_result = na
    if not na(movingAverage) and movingAverage != 0
        bias_result := (src - movingAverage) / movingAverage
    bias_result

//@function Calculates Pearson correlation coefficient using single pass with circular buffer
//@param src1 First series to analyze
//@param src2 Second series to analyze
//@param len Lookback period for calculation
//@returns Pearson correlation coefficient between -1 and 1
export correlation(series float src1, series float src2, simple int len) =>
    if len <= 0
        runtime.error("Period must be greater than 0")
    var int p = math.max(1, len)
    var array<float> buffer1 = array.new_float(p, na)
    var array<float> buffer2 = array.new_float(p, na)
    var int head = 0, var int count = 0
    var float sum1 = 0.0, var float sum2 = 0.0
    var float sumSq1 = 0.0, var float sumSq2 = 0.0
    var float sumProd = 0.0
    float oldest1 = array.get(buffer1, head)
    float oldest2 = array.get(buffer2, head)
    if not na(oldest1) and not na(oldest2)
        sum1 -= oldest1, sum2 -= oldest2
        sumSq1 -= oldest1 * oldest1, sumSq2 -= oldest2 * oldest2
        sumProd -= oldest1 * oldest2
        count -= 1
    if not na(src1) and not na(src2)
        sum1 += src1, sum2 += src2
        sumSq1 += src1 * src1, sumSq2 += src2 * src2
        sumProd += src1 * src2
        count += 1
        array.set(buffer1, head, src1)
        array.set(buffer2, head, src2)
    else
        array.set(buffer1, head, na)
        array.set(buffer2, head, na)
    head := (head + 1) % p
    if count > 1
        mean1 = sum1 / count, mean2 = sum2 / count
        cov = (sumProd / count) - mean1 * mean2
        var1 = (sumSq1 / count) - mean1 * mean1
        var2 = (sumSq2 / count) - mean2 * mean2
        stddev1 = math.sqrt(math.max(0.0, var1))
        stddev2 = math.sqrt(math.max(0.0, var2))
        denominator = stddev1 * stddev2
        if denominator != 0
            cov / denominator
        else
            na
    else
        na

//@function Calculates covariance using single pass with circular buffer
//@param src1 First series to analyze
//@param src2 Second series to analyze
//@param len Lookback period for calculation
//@returns Covariance between src1 and src2
export covariance(series float src1, series float src2, simple int len) =>
    if len <= 0
        runtime.error("Period must be greater than 0")
    var int p = math.max(1, len)
    var array<float> buffer1 = array.new_float(p, na)
    var array<float> buffer2 = array.new_float(p, na)
    var int head = 0, var int count = 0
    var float sum1 = 0.0, var float sum2 = 0.0
    var float sumProd = 0.0
    float oldest1 = array.get(buffer1, head)
    float oldest2 = array.get(buffer2, head)
    if not na(oldest1) and not na(oldest2)
        sum1 -= oldest1
        sum2 -= oldest2
        sumProd -= oldest1 * oldest2
        count -= 1
    if not na(src1) and not na(src2)
        sum1 += src1
        sum2 += src2
        sumProd += src1 * src2
        count += 1
        array.set(buffer1, head, src1)
        array.set(buffer2, head, src2)
    else
        array.set(buffer1, head, na)
        array.set(buffer2, head, na)
    head := (head + 1) % p
    count > 1 ? (sumProd / count) - (sum1 / count) * (sum2 / count) : na

//@function Calculates the cumulative arithmetic mean (average) of a series from the start
//@param src Input data series
//@returns The cumulative mean of the series, or na if all data so far is na
export cummean(series float src) =>
    var float cumulative_sum = 0.0
    var int valid_data_count = 0
    if not na(src)
        cumulative_sum += src
        valid_data_count += 1
    valid_data_count > 0 ? cumulative_sum / valid_data_count : na

//@function Calculates the Geometric Mean of a series over a lookback period
//@param src Input data series (must contain positive values)
//@param len Lookback period
//@returns The Geometric Mean, or na if data is not suitable
export geomean(series float src, simple int len) =>
    if len <= 0
        runtime.error("Period must be greater than 0. Found: " + str.tostring(len))
    var float sum_log_src = 0.0
    var int n_valid = 0
    var float[] src_buffer = array.new_float(len, na)
    var int current_index = 0
    float current_val = src
    float current_log_val = na
    bool current_val_is_valid = false
    if not na(current_val) and current_val > 0
        current_log_val := math.log(current_val)
        current_val_is_valid := true
    float old_src_from_buffer = array.get(src_buffer, current_index)
    if not na(old_src_from_buffer) and old_src_from_buffer > 0
        sum_log_src -= math.log(old_src_from_buffer)
        n_valid -= 1
    if current_val_is_valid
        sum_log_src += current_log_val
        n_valid += 1
        array.set(src_buffer, current_index, current_val)
    else
        array.set(src_buffer, current_index, na)
    current_index := (current_index + 1) % len
    if n_valid > 0
        math.exp(sum_log_src / n_valid)
    else
        float(na)

//@function Calculates the Harmonic Mean of a series over a lookback period
//@param src Input data series (must contain positive values)
//@param len Lookback period
//@returns The Harmonic Mean, or na if data is not suitable
export harmean(series float src, simple int len) =>
    if len <= 0
        runtime.error("Period must be greater than 0. Found: " + str.tostring(len))
    var float sum_reciprocal_src = 0.0
    var int n_valid = 0
    var float[] src_buffer = array.new_float(len, na)
    var int current_index = 0
    float current_val = src
    bool current_val_is_valid = false
    if not na(current_val) and current_val > 0
        current_val_is_valid := true
    float old_val_from_buffer = array.get(src_buffer, current_index)
    if not na(old_val_from_buffer) and old_val_from_buffer > 0
        sum_reciprocal_src -= 1.0 / old_val_from_buffer
        n_valid -= 1
    if current_val_is_valid
        sum_reciprocal_src += 1.0 / current_val
        n_valid += 1
        array.set(src_buffer, current_index, current_val)
    else
        array.set(src_buffer, current_index, na)
    current_index := (current_index + 1) % len
    if n_valid > 0
        n_valid / sum_reciprocal_src
    else
        float(na)

//@function Calculates the Interquartile Range (IQR)
//@param src Input data series
//@param len Lookback period
//@returns The IQR value
export iqr(series float src, simple int len) =>
    if len <= 0
        runtime.error("Length must be greater than 0")
    var array<float> values = array.new_float(0)
    array.clear(values)
    for i = 0 to len - 1
        val = src[i]
        if not na(val)
            array.push(values, val)
    int n = array.size(values)
    float result = na
    if n >= 2
        array.sort(values)
        float q1_pos = (n - 1) * 0.25
        float q3_pos = (n - 1) * 0.75
        int q1_lower = math.floor(q1_pos)
        int q1_upper = math.ceil(q1_pos)
        int q3_lower = math.floor(q3_pos)
        int q3_upper = math.ceil(q3_pos)
        float q1 = q1_lower == q1_upper ? array.get(values, q1_lower) : array.get(values, q1_lower) * (q1_upper - q1_pos) + array.get(values, q1_upper) * (q1_pos - q1_lower)
        float q3 = q3_lower == q3_upper ? array.get(values, q3_lower) : array.get(values, q3_lower) * (q3_upper - q3_pos) + array.get(values, q3_upper) * (q3_pos - q3_lower)
        result := q3 - q1
    result

//@function Calculates kurtosis (measure of tail heaviness) of a series
//@param src Input data series
//@param len Lookback period
//@returns Kurtosis value
export kurtosis(series float src, simple int len) =>
    if len <= 3
        runtime.error("Period must be greater than 3")
    var int p = math.max(4, len)
    var array<float> buffer = array.new_float(p, na)
    var int head = 0, var int count = 0
    var float sum = 0.0, var float sumSq = 0.0
    var float sumCube = 0.0, var float sumQuad = 0.0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
        sumSq -= oldest * oldest
        sumCube -= oldest * oldest * oldest
        sumQuad -= oldest * oldest * oldest * oldest
        count -= 1
    float val = nz(src)
    sum += val
    sumSq += val * val
    sumCube += val * val * val
    sumQuad += val * val * val * val
    count += 1
    array.set(buffer, head, val)
    head := (head + 1) % p
    if count > 3
        mean = sum / count
        m2 = (sumSq / count) - mean * mean
        m3 = (sumCube / count) - 3 * mean * m2 - mean * mean * mean
        m4 = (sumQuad / count) - 4 * mean * m3 - 6 * mean * mean * m2 - mean * mean * mean * mean
        variance = m2
        if variance > 1e-10
            (m4 / (variance * variance)) - 3.0
        else
            na
    else
        na

//@function Calculates linear regression slope and intercept
//@param src Source series
//@param len Lookback period
//@returns [intercept, slope]
export linreg(series float src, simple int len) =>
    if len < 2
        [na, na]
    else
        var float lastValid = na
        var array<float> buf = array.new_float(len, 0.0)
        var int count = 0
        var int head = 0
        float curr = src
        if na(curr) and not na(lastValid)
            curr := lastValid
        if not na(curr)
            lastValid := curr
        if not na(curr)
            array.set(buf, head, curr)
            count := count < len ? count + 1 : len
            head := (head + 1) % len
        if count >= 2
            float sumX = 0.0, float sumY = 0.0, float sumXY = 0.0, float sumX2 = 0.0
            for i = 0 to count - 1
                x = i
                y = array.get(buf, (head - count + i + len) % len)
                sumX += x, sumY += y, sumXY += x * y, sumX2 += x * x
            n = count
            slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX)
            intercept = (sumY - slope * sumX) / n
            [intercept, slope]
        else
            [na, na]

//@function Calculates the median of a series over a lookback period
//@param src Input data series
//@param len Lookback period
//@returns The median of the series over the period
export median(series float src, simple int len) =>
    if len <= 0
        runtime.error("Length must be greater than 0")
    var array<float> values_in_window = array.new_float(0)
    array.clear(values_in_window)
    for i = 0 to len - 1
        val = src[i]
        if not na(val)
            array.push(values_in_window, val)
    int n = array.size(values_in_window)
    float result = na
    if n > 0
        array.sort(values_in_window)
        if n % 2 == 1
            result := array.get(values_in_window, n / 2)
        else
            mid1 = array.get(values_in_window, n / 2 - 1)
            mid2 = array.get(values_in_window, n / 2)
            result := (mid1 + mid2) / 2.0
    result

//@function Calculates the mode (most frequent value) of a series
//@param src Input data series
//@param len Lookback period
//@param bins Number of bins for bucketing
//@returns The mode value
export mode(series float src, simple int len, simple int bins = 20) =>
    if len <= 0
        runtime.error("Length must be greater than 0")
    if bins <= 0
        runtime.error("Bins must be greater than 0")
    var array<float> values = array.new_float(0)
    array.clear(values)
    float minVal = na, float maxVal = na
    for i = 0 to len - 1
        val = src[i]
        if not na(val)
            array.push(values, val)
            minVal := na(minVal) ? val : math.min(minVal, val)
            maxVal := na(maxVal) ? val : math.max(maxVal, val)
    int n = array.size(values)
    float result = na
    if n > 0 and not na(minVal) and not na(maxVal)
        range_val = maxVal - minVal
        if range_val < 1e-10
            result := minVal
        else
            var array<int> freq = array.new_int(bins, 0)
            array.clear(freq)
            for j = 0 to bins - 1
                array.set(freq, j, 0)
            for j = 0 to n - 1
                val = array.get(values, j)
                bucket = math.floor(((val - minVal) / range_val) * bins)
                bucket := math.max(0, math.min(bucket, bins - 1))
                array.set(freq, bucket, array.get(freq, bucket) + 1)
            maxFreq = 0, modeBucket = 0
            for j = 0 to bins - 1
                freq_val = array.get(freq, j)
                if freq_val > maxFreq
                    maxFreq := freq_val
                    modeBucket := j
            result := minVal + (modeBucket + 0.5) * (range_val / bins)
    result

//@function Calculates the value at a given percentile
//@param src Input data series
//@param len Lookback period
//@param p Percentile to calculate (0-100)
//@returns The value at the specified percentile
export percentile(series float src, simple int len, simple float p) =>
    if len <= 0
        runtime.error("Length must be greater than 0.")
    if p < 0 or p > 100
        runtime.error("Percentile 'p' must be between 0 and 100.")
    data_points = array.new_float()
    for i = 0 to len - 1
        val = src[i]
        if not na(val)
            array.push(data_points, val)
    n_valid = array.size(data_points)
    float result = na
    if n_valid == 0
        result := na
    else if n_valid == 1
        result := array.get(data_points, 0)
    else
        array.sort(data_points)
        rank = (p / 100.0) * (n_valid - 1)
        lower_index = math.floor(rank)
        upper_index = math.ceil(rank)
        lower_val = array.get(data_points, lower_index)
        upper_val = array.get(data_points, upper_index)
        fraction = rank - lower_index
        result := lower_val + fraction * (upper_val - lower_val)
    result

//@function Calculates the quantile of a series using linear interpolation
//@param src The source series
//@param len The lookback period
//@param q_level The quantile level (between 0.0 and 1.0)
//@returns The calculated quantile value
export quantile(series float src, simple int len, simple float q_level) =>
    if len <= 0
        runtime.error("Period must be greater than 0.")
    if q_level < 0.0 or q_level > 1.0
        runtime.error("Quantile Level must be between 0.0 and 1.0.")
    var float[] values_arr = array.new_float(0)
    array.clear(values_arr)
    for i = 0 to len - 1
        if not na(src[i])
            array.push(values_arr, src[i])
    int n_valid = array.size(values_arr)
    if n_valid == 0
        na
    else if n_valid == 1
        array.get(values_arr, 0)
    else
        array.sort(values_arr)
        pos = q_level * (n_valid - 1)
        lower_idx = math.floor(pos)
        upper_idx = math.ceil(pos)
        lower_val = array.get(values_arr, lower_idx)
        upper_val = array.get(values_arr, upper_idx)
        weight = pos - lower_idx
        lower_val + weight * (upper_val - lower_val)

//@function Calculates skewness (measure of asymmetry) of a series
//@param src Input data series
//@param len Lookback period
//@returns Skewness value
export skew(series float src, simple int len) =>
    if len <= 2
        runtime.error("Period must be greater than 2")
    var int p = math.max(3, len)
    var array<float> buffer = array.new_float(p, na)
    var int head = 0, var int count = 0
    var float sum = 0.0, var float sumSq = 0.0
    var float sumCube = 0.0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
        sumSq -= oldest * oldest
        sumCube -= oldest * oldest * oldest
        count -= 1
    float val = nz(src)
    sum += val
    sumSq += val * val
    sumCube += val * val * val
    count += 1
    array.set(buffer, head, val)
    head := (head + 1) % p
    if count > 2
        mean = sum / count
        m2 = (sumSq / count) - mean * mean
        m3 = (sumCube / count) - 3 * mean * m2 - mean * mean * mean
        variance = m2
        stddev = math.sqrt(math.max(0.0, variance))
        if stddev > 1e-10
            m3 / (stddev * stddev * stddev)
        else
            na
    else
        na

//@function Calculates the standard deviation using a single pass with a circular buffer
//@param src Source series
//@param len Lookback length
//@returns Standard deviation of src for len bars back
export stddev(series float src, simple int len) =>
    if len <= 0
        runtime.error("Period must be greater than 0")
    var int p = math.max(1, len)
    var array<float> buffer = array.new_float(p, na)
    var int head = 0,  var int count = 0
    var float sum = 0.0, var float sumSq = 0.0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
        sumSq -= oldest * oldest
        count -= 1
    float val = nz(src)
    sum += val
    sumSq += val * val
    count += 1
    array.set(buffer, head, val)
    head := (head + 1) % p
    count > 1 ? math.sqrt(math.max(0.0, (sumSq / count) - math.pow(sum / count, 2))) : 0.0

//@function Calculates variance using a single pass with a circular buffer
//@param src Source series
//@param len Lookback length
//@returns Variance of src for len bars back
export variance(series float src, simple int len) =>
    if len <= 0
        runtime.error("Period must be greater than 0")
    var int p = math.max(1, len)
    var array<float> buffer = array.new_float(p, na)
    var int head = 0,  var int count = 0
    var float sum = 0.0, var float sumSq = 0.0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
        sumSq -= oldest * oldest
        count -= 1
    float val = nz(src)
    sum += val
    sumSq += val * val
    count += 1
    array.set(buffer, head, val)
    head := (head + 1) % p
    count > 1 ? math.max(0.0, (sumSq / count) - math.pow(sum / count, 2)) : 0.0

//@function Calculates the Z-Score of a series over a lookback period
//@param src Source series
//@param len Lookback period
//@returns The Z-Score value
export zscore(series float src, simple int len) =>
    if len <= 1
        runtime.error("Length must be greater than 1")
    var float sumY = 0.0, var float sumY2 = 0.0
    var int validCount = 0
    var array<float> y_values = array.new_float(len)
    var int head = 0
    var bool filled = false
    float oldY = filled ? array.get(y_values, head) : na
    if not na(oldY)
        sumY -= oldY, sumY2 -= oldY * oldY, validCount -= 1
    float currentY = src
    array.set(y_values, head, currentY)
    if not na(currentY)
        sumY += currentY, sumY2 += currentY * currentY, validCount += 1
    head := (head + 1) % len
    filled := filled or head == 0
    if validCount > 1
        mean = sumY / validCount
        variance = (sumY2 / validCount) - (mean * mean)
        stddev = math.sqrt(math.max(0.0, variance))
        if stddev > 1e-10
            (currentY - mean) / stddev
        else
            na
    else
        na
