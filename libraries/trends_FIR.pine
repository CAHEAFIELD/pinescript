// The MIT License (MIT)
// Â© mihakralj
//@version=6
//@description Library of FIR (Finite Impulse Response) trend filters - 17 self-contained moving averages with no external dependencies

library("trends_FIR", overlay=true)

//@function Simple Moving Average - arithmetic mean with O(1) circular buffer
//@param source Series to calculate SMA from
//@param period Lookback period
//@returns SMA value from first bar
export sma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = period
    var array<float> buffer = array.new_float(p, na)
    var int head = 0
    var float sum = 0.0
    var int count = 0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
    else
        count += 1
    float current = nz(source)
    sum += current
    array.set(buffer, head, current)
    head := (head + 1) % p
    sum / math.max(1, count)

//@function Weighted Moving Average - linearly declining weights
//@param source Series to calculate WMA from
//@param period Lookback period
//@returns WMA value from first bar
export wma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.min(bar_index + 1, math.min(period, 4000))
    var int last_p = 1
    var float weight_sum = 1.0
    if last_p != p
        weight_sum := p * (p + 1) * 0.5
        last_p := p
    float sum = 0.0
    float actual_weight = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = p - i
            sum += price * w
            actual_weight += w
    nz(sum / actual_weight, source)

//@function Double Weighted Moving Average - two-pass WMA
//@param source Series to calculate DWMA from
//@param period Lookback period
//@returns DWMA value from first bar
export dwma(series float src, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.max(1, math.min(math.min(bar_index + 1, period), 4000))
    if p <= 1
        src
    else
        float sum1 = 0.0
        int weightSum1 = 0
        for i = 0 to p - 1
            float price = src[i]
            if not na(price)
                int weight = p - i
                sum1 += price * weight
                weightSum1 += weight
        float currentWma = nz(sum1 / weightSum1, na)
        var float[] wmaBuffer = array.new_float(period, na)
        var int bufferPos = 0
        var int validCount = 0
        array.set(wmaBuffer, bufferPos, currentWma)
        bufferPos := (bufferPos + 1) % period
        validCount := math.min(validCount + 1, period)
        if validCount <= 0
            na
        else
            float sum2 = 0.0
            int weightSum2 = 0
            for i = 0 to validCount - 1
                int idx = (bufferPos - 1 - i + period) % period
                float wmaVal = array.get(wmaBuffer, idx)
                if not na(wmaVal)
                    int weight = p - i
                    sum2 += wmaVal * weight
                    weightSum2 += weight
            nz(sum2 / weightSum2, na)

//@function Endpoint Moving Average - linear weighting with endpoint emphasis
//@param source Series to calculate EPMA from
//@param period Lookback period
//@returns EPMA value from first bar
export epma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.max(1, math.min(bar_index + 1, period))
    if p <= 1
        source
    else
        float weightedSum = 0.0
        float totalWeight = 0.0
        for i = 0 to p - 1
            float price = source[i]
            if not na(price)
                int weight = p - i
                weightedSum += price * weight
                totalWeight += weight
        nz(weightedSum / totalWeight, na)

// =============================================================================
// TRIANGULAR & SHAPED MOVING AVERAGES
// =============================================================================

//@function Triangular Moving Average - triangular weighted smoothing
//@param source Series to calculate TRIMA from
//@param period Lookback period
//@returns TRIMA value from first bar
export trima(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.min(bar_index + 1, period)
    var array<float> weights = array.new_float(1, 1.0)
    var int last_p = 1
    if last_p != p
        weights := array.new_float(p, 0.0)
        int mid = math.floor(p / 2)
        for i = 0 to p - 1
            array.set(weights, i, math.min(i, p - 1 - i) + 1)
        last_p := p
    float sum = 0.0
    float weight_sum = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(weights, i)
            sum += price * w
            weight_sum += w
    nz(sum / weight_sum, source)

//@function Sine-weighted Moving Average - sine wave weighting
//@param source Series to calculate SINEMA from
//@param period Lookback period
//@returns SINEMA value from first bar
export sinema(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.min(bar_index + 1, period)
    var int prev_p = 0
    var array<float> sine_weights = array.new_float(period, 0.0)
    if p != prev_p
        sine_weights := array.new_float(p, 0.0)
        for j = 0 to p - 1
            array.set(sine_weights, j, math.sin(math.pi * (j + 1) / p))
        prev_p := p
    float sum = 0.0
    float weight = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(sine_weights, i)
            sum += price * w
            weight += w
    nz(sum / weight, source)

//@function Pascal Weighted Moving Average - Pascal's triangle coefficients
//@param source Series to calculate PWMA from
//@param period Lookback period
//@returns PWMA value from first bar
export pwma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.min(bar_index + 1, period)
    var array<float> weights = array.new_float(1, 1.0)
    var int last_p = 1
    if last_p != p
        weights := array.new_float(p, 0.0)
        array.set(weights, 0, 1.0)
        if p > 1
            float prev_weight = 1.0
            for i = 1 to p - 1
                float curr_weight = prev_weight * (p - i) / i
                array.set(weights, i, curr_weight)
                prev_weight := curr_weight
        last_p := p
    float sum = 0.0
    float weight_sum = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(weights, i)
            sum += price * w
            weight_sum += w
    nz(sum / weight_sum, source)

// =============================================================================
// GAUSSIAN & WINDOW FUNCTION MOVING AVERAGES
// =============================================================================

//@function Arnaud Legoux Moving Average - Gaussian distribution weights
//@param source Series to calculate ALMA from
//@param period Lookback period
//@param offset Gaussian peak location (0 to 1)
//@param sigma Gaussian distribution width
//@returns ALMA value from first bar
export alma(series float source, simple int period, simple float offset=0.85, simple float sigma=6.0) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    if offset < 0.0 or offset > 1.0
        runtime.error("Offset must be between 0 and 1")
    if sigma <= 0.0
        runtime.error("Sigma must be greater than 0")
    int p = math.min(bar_index + 1, period)
    if p <= 1
        source
    else
        float m = (1.0 - offset) * (p - 1)
        float s = p / sigma
        float s2 = 2.0 * (s * s)
        float sum = 0.0
        float weight_sum = 0.0
        for i = 0 to p - 1
            float price = source[i]
            if not na(price)
                float diff = i - m
                float weight = math.exp(-(diff * diff) / s2)
                sum += price * weight
                weight_sum += weight
        nz(sum / weight_sum, source)

//@function Gaussian-Weighted Moving Average - Gaussian window weighting
//@param source Series to calculate GWMA from
//@param period Lookback period
//@param sigma Controls width of Gaussian bell curve
//@returns GWMA value from first bar
export gwma(series float source, simple int period, simple float sigma=0.4) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.min(bar_index + 1, period)
    var array<float> weights = array.new_float(1, 1.0)
    var int last_p = 1
    var float last_sigma = sigma
    if last_p != p or last_sigma != sigma
        weights := array.new_float(p, 0.0)
        float center = (p - 1) / 2.0
        float inv_sigmap = 1.0 / (sigma * p)
        float total = 0.0
        for i = 0 to p - 1
            float x = (i - center) * inv_sigmap
            float w = math.exp(-0.5 * x * x)
            array.set(weights, i, w)
            total += w
        float inv_total = 1.0 / total
        for i = 0 to p - 1
            array.set(weights, i, array.get(weights, i) * inv_total)
        last_p := p
        last_sigma := sigma
    float sum = 0.0
    float weight_sum = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(weights, i)
            sum += price * w
            weight_sum += w
    nz(sum / weight_sum, source)

//@function Hamming Moving Average - Hamming window weighting
//@param source Series to calculate HAMMA from
//@param period Lookback period
//@returns HAMMA value from first bar
export hamma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.min(bar_index + 1, period)
    var array<float> weights = array.new_float(1, 1.0)
    var int last_p = 1
    if last_p != p
        weights := array.new_float(p, 0.0)
        for i = 0 to p - 1
            float w = 0.54 - 0.46 * math.cos(2.0 * math.pi * i / (p - 1))
            array.set(weights, i, w)
        last_p := p
    float sum = 0.0
    float weight_sum = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(weights, i)
            sum += price * w
            weight_sum += w
    nz(sum / weight_sum, source)

//@function Hanning Moving Average - Hanning window weighting
//@param source Series to calculate HANMA from
//@param period Lookback period
//@returns HANMA value from first bar
export hanma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.min(bar_index + 1, period)
    var array<float> weights = array.new_float(1, 1.0)
    var int last_p = 1
    if last_p != p
        weights := array.new_float(p, 0.0)
        for i = 0 to p - 1
            float w = 0.5 * (1.0 - math.cos(2.0 * math.pi * i / (p - 1)))
            array.set(weights, i, w)
        last_p := p
    float sum = 0.0
    float weight_sum = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(weights, i)
            sum += price * w
            weight_sum += w
    nz(sum / weight_sum, source)

//@function Blackman Moving Average - Blackman window weighting
//@param source Series to calculate BLMA from
//@param period Lookback period
//@returns BLMA value from first bar
export blma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.min(bar_index + 1, period)
    var array<float> weights = array.new_float(1, 1.0)
    var int last_p = 1
    if last_p != p
        weights := array.new_float(p, 0.0)
        float total_weight = 0.0
        float a0 = 0.42
        float a1 = 0.5
        float a2 = 0.08
        float inv_p_minus_1 = 1.0 / (p - 1)
        float pi2 = 2.0 * math.pi
        float pi4 = 4.0 * math.pi
        for i = 0 to p - 1
            float ratio = i * inv_p_minus_1
            float term1 = a1 * math.cos(pi2 * ratio)
            float term2 = a2 * math.cos(pi4 * ratio)
            float w = a0 - term1 + term2
            array.set(weights, i, w)
            total_weight += w
        float inv_total = 1.0 / total_weight
        for i = 0 to p - 1
            array.set(weights, i, array.get(weights, i) * inv_total)
        last_p := p
    float sum = 0.0
    float weight_sum = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(weights, i)
            sum += price * w
            weight_sum += w
    nz(sum / weight_sum, source)

//@function Bessel-Weighted Moving Average - Bessel window weighting
//@param source Series to calculate BWMA from
//@param period Lookback period
//@param order Bessel function order
//@returns BWMA value from first bar
export bwma(series float source, simple int period, simple int order=0) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    if order < 0
        runtime.error("Bessel order must be non-negative")
    int p = math.min(bar_index + 1, period)
    var array<float> weights = array.new_float(1, 1.0)
    var int last_p = 1
    var int last_order = order
    if last_p != p or last_order != order
        weights := array.new_float(p, 0.0)
        float total_weight = 0.0
        float scale = 2.0 / (p - 1)
        float power = order / 2.0 + 0.5
        for i = 0 to p - 1
            float x = i * scale - 1.0
            float arg = 1.0 - x * x
            float w = 0.0
            if arg > 0.0
                if order == 0
                    w := arg
                else if order == 1
                    w := arg * math.sqrt(arg)
                else
                    w := math.pow(arg, power)
            array.set(weights, i, w)
            total_weight += w
        if total_weight > 0.0
            float inv_total = 1.0 / total_weight
            for i = 0 to p - 1
                array.set(weights, i, array.get(weights, i) * inv_total)
        last_p := p
        last_order := order
    float sum = 0.0
    float weight_sum = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(weights, i)
            sum += price * w
            weight_sum += w
    nz(sum / weight_sum, source)

// =============================================================================
// COMPOSITE & ADVANCED MOVING AVERAGES
// =============================================================================

//@function Hull Moving Average - composite WMA for lag reduction
//@param source Series to calculate HMA from
//@param period Lookback period
//@returns HMA value from first bar
export hma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int p = math.min(bar_index + 1, period)
    int half_p = math.max(1, math.round(p / 2))
    int sqrt_p = math.max(1, math.round(math.sqrt(p)))
    float sum_half = 0.0
    float sum_full = 0.0
    float sum_sqrt = 0.0
    float weight_half = 0.0
    float weight_full = 0.0
    float weight_sqrt = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w_half = i < half_p ? half_p - i : 0
            float w_full = p - i
            sum_half += price * w_half
            sum_full += price * w_full
            weight_half += w_half
            weight_full += w_full
    float wma_half = nz(sum_half / weight_half, na)
    float wma_full = nz(sum_full / weight_full, na)
    float diff = na(wma_half) or na(wma_full) ? na : 2.0 * wma_half - wma_full
    for i = 0 to sqrt_p - 1
        float d = diff[i]
        if not na(d)
            float w_sqrt = sqrt_p - i
            sum_sqrt += d * w_sqrt
            weight_sqrt += w_sqrt
    nz(sum_sqrt / weight_sqrt, na)

//@function Holt-Winters Moving Average - triple exponential smoothing
//@param source Series to calculate HWMA from
//@param alpha Level smoothing factor
//@param beta Velocity smoothing factor
//@param gamma Acceleration smoothing factor
//@param period When used, calculate alpha/beta/gamma from period
//@returns HWMA value from first bar
export hwma(series float source, float alpha=0.0, float beta=0.0, float gamma=0.0, simple int period=0) =>
    float a = period > 0 ? 2.0 / (float(period) + 1.0) : alpha
    float b = period > 0 ? 1.0 / float(period) : beta
    float g = period > 0 ? 1.0 / float(period) : gamma
    var float F = na
    var float V = 0.0
    var float A = 0.0
    if na(source)
        if na(F)
            na
        else
            float prevF = F
            float prevV = V
            float prevA = A
            F := prevF + prevV + 0.5 * prevA
            V := prevV + prevA
            A := 0.9 * prevA
            F
    else
        if na(F)
            F := source
            F
        else
            float prevF = F
            float prevV = V
            float prevA = A
            F := a * source + (1.0 - a) * (prevF + prevV + 0.5 * prevA)
            V := b * (F - prevF) + (1.0 - b) * (prevV + prevA)
            A := g * (V - prevV) + (1.0 - g) * prevA
            F + V + 0.5 * A

//@function Least Squares Moving Average - linear regression fit
//@param source Series to calculate LSMA from
//@param period Lookback period
//@returns LSMA value from first bar
export lsma(series float source, simple int period) =>
    if period <= 1
        runtime.error("Period must be greater than 1")
        source
    else
        int p = math.min(bar_index + 1, period)
        if p <= 1
            source
        else
            var array<float> buffer = array.new_float(period, na)
            var int head = 0
            array.set(buffer, head, source)
            head := (head + 1) % period
            float sum_y = 0.0
            float sum_xy = 0.0
            float sum_x = 0.0
            float sum_x2 = 0.0
            float count = 0.0
            int idx = (head - 1 + period) % period
            for i = 0 to p - 1
                float val = array.get(buffer, idx)
                if not na(val)
                    sum_x += i
                    sum_y += val
                    sum_xy += i * val
                    sum_x2 += i * i
                    count += 1.0
                idx := (idx - 1 + period) % period
            if count <= 1.0
                source
            else
                float denom = count * sum_x2 - sum_x * sum_x
                if denom == 0.0
                    source
                else
                    float slope = (count * sum_xy - sum_x * sum_y) / denom
                    float intercept = (sum_y - slope * sum_x) / count
                    intercept

//@function Savitzky-Golay Moving Average - polynomial fitting filter
//@param source Series to calculate SGMA from
//@param period Lookback period (must be odd)
//@param deg Polynomial degree
//@returns SGMA value from first bar
export sgma(series float source, simple int period, simple int deg=2) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int use_period = period % 2 == 0 ? period + 1 : period
    int use_deg = deg < 0 or deg >= use_period ? 2 : math.min(deg, 4)
    int p = math.min(bar_index + 1, use_period)
    var array<float> weights = array.new_float(1, 1.0)
    var int last_p = 1
    var int last_deg = use_deg
    if last_p != p or last_deg != use_deg
        weights := array.new_float(p, 0.0)
        if use_deg == 2
            if p == 5
                array.set(weights, 0, -0.0857)
                array.set(weights, 1, 0.3429)
                array.set(weights, 2, 0.4857)
                array.set(weights, 3, 0.3429)
                array.set(weights, 4, -0.0857)
            else if p == 7
                array.set(weights, 0, -0.0476)
                array.set(weights, 1, 0.0952)
                array.set(weights, 2, 0.2857)
                array.set(weights, 3, 0.3333)
                array.set(weights, 4, 0.2857)
                array.set(weights, 5, 0.0952)
                array.set(weights, 6, -0.0476)
            else if p == 9
                array.set(weights, 0, -0.0281)
                array.set(weights, 1, 0.0337)
                array.set(weights, 2, 0.1236)
                array.set(weights, 3, 0.2247)
                array.set(weights, 4, 0.2921)
                array.set(weights, 5, 0.2247)
                array.set(weights, 6, 0.1236)
                array.set(weights, 7, 0.0337)
                array.set(weights, 8, -0.0281)
            else
                float half_window = (p - 1) / 2.0
                float total_weight = 0.0
                for i = 0 to p - 1
                    float x = i - half_window
                    float norm_x = x / half_window
                    float w = 1.0 - norm_x * norm_x
                    array.set(weights, i, w)
                    total_weight += w
                float inv_total = 1.0 / total_weight
                for i = 0 to p - 1
                    array.set(weights, i, array.get(weights, i) * inv_total)
        else
            float half_window = (p - 1) / 2.0
            float total_weight = 0.0
            for i = 0 to p - 1
                float x = i - half_window
                float norm_x = x / half_window
                float w = 0.0
                if use_deg == 0
                    w := 1.0
                else if use_deg == 1
                    w := 1.0 - math.abs(norm_x)
                else if use_deg == 3
                    w := 1.0 - math.abs(math.pow(norm_x, 3.0))
                else if use_deg == 4
                    w := 1.0 - math.pow(norm_x, 4.0)
                else
                    w := 1.0 - norm_x * norm_x
                array.set(weights, i, w)
                total_weight += w
            if total_weight > 0.0
                float inv_total = 1.0 / total_weight
                for i = 0 to p - 1
                    array.set(weights, i, array.get(weights, i) * inv_total)
        last_p := p
        last_deg := use_deg
    float sum = 0.0
    float weight_sum = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(weights, i)
            sum += price * w
            weight_sum += w
    nz(sum / weight_sum, source)

//@function Convolution Moving Average - custom kernel convolution
//@param source Series to calculate CONV from
//@param kernel Array of weights to use as convolution kernel
//@returns CONV value from first bar
export conv(series float source, simple array<float> kernel) =>
    int kernel_size = array.size(kernel)
    if kernel_size <= 0
        runtime.error("Kernel must not be empty")
    var array<float> norm_kernel = array.new_float(1, 1.0)
    var int last_kernel_size = 1
    if last_kernel_size != kernel_size
        norm_kernel := array.copy(kernel)
        float kernel_sum = 0.0
        for i = 0 to kernel_size - 1
            kernel_sum += array.get(kernel, i)
        if kernel_sum != 0.0
            float inv_sum = 1.0 / kernel_sum
            for i = 0 to kernel_size - 1
                array.set(norm_kernel, i, array.get(kernel, i) * inv_sum)
        last_kernel_size := kernel_size
    int p = math.min(bar_index + 1, kernel_size)
    float sum = 0.0
    float weight_sum = 0.0
    for i = 0 to p - 1
        float price = source[i]
        if not na(price)
            float w = array.get(norm_kernel, i)
            sum += price * w
            weight_sum += w
    nz(sum / weight_sum, source)
