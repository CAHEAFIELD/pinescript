// The MIT License (MIT)
// Â© mihakralj
//@version=6
//@description Library of volatility indicators - 26 self-contained volatility measures with no external dependencies

library("volatility", overlay=false)

// =============================================================================
// BASIC RANGE MEASURES
// =============================================================================

//@function True Range - fundamental volatility measure
//@returns True Range value for current bar
export tr() =>
    float prevClose = nz(close[1], close)
    float tr1 = high - low
    float tr2 = math.abs(high - prevClose)
    float tr3 = math.abs(low - prevClose)
    math.max(tr1, math.max(tr2, tr3))

//@function Average True Range - smoothed true range
//@param length Period for ATR calculation
//@returns ATR value
export atr(simple int length) =>
    if length <= 0
        runtime.error("Period must be greater than 0")
    var float prevClose = close
    float tr1 = high - low
    float tr2 = math.abs(high - prevClose)
    float tr3 = math.abs(low - prevClose)
    float trueRange = math.max(tr1, tr2, tr3)
    prevClose := close
    float alpha = 1.0 / float(length)
    float beta = 1.0 - alpha
    var float EPSILON = 1e-10
    var float raw_rma = 0.0
    var float e = 1.0
    if not na(trueRange)
        raw_rma := (raw_rma * (length - 1) + trueRange) / length
        e *= beta
        e > EPSILON ? raw_rma / (1.0 - e) : raw_rma
    else
        na

//@function Normalized ATR - ATR as percentage of price
//@param length Period for ATR calculation
//@returns NATR value as percentage
export natr(simple int length) =>
    if length <= 0
        runtime.error("Period must be greater than 0")
    var float prevClose = close
    float tr1 = high - low
    float tr2 = math.abs(high - prevClose)
    float tr3 = math.abs(low - prevClose)
    float trueRange = math.max(tr1, tr2, tr3)
    prevClose := close
    float alpha = 1.0 / float(length)
    float beta = 1.0 - alpha
    var float EPSILON = 1e-10
    var float raw_rma = 0.0
    var float e = 1.0
    if not na(trueRange)
        raw_rma := (raw_rma * (length - 1) + trueRange) / length
        e *= beta
        float atr_val = e > EPSILON ? raw_rma / (1.0 - e) : raw_rma
        close > 0 ? (atr_val / close) * 100 : na
    else
        na

//@function ATR Normalized - ATR divided by typical price
//@param length Period for ATR calculation
//@returns ATRN value
export atrn(simple int length) =>
    if length <= 0
        runtime.error("Period must be greater than 0")
    var float prevClose = close
    float tr1 = high - low
    float tr2 = math.abs(high - prevClose)
    float tr3 = math.abs(low - prevClose)
    float trueRange = math.max(tr1, tr2, tr3)
    prevClose := close
    float typicalPrice = (high + low + close) / 3
    float alpha = 1.0 / float(length)
    float beta = 1.0 - alpha
    var float EPSILON = 1e-10
    var float raw_rma = 0.0
    var float e = 1.0
    if not na(trueRange)
        raw_rma := (raw_rma * (length - 1) + trueRange) / length
        e *= beta
        float atr_val = e > EPSILON ? raw_rma / (1.0 - e) : raw_rma
        typicalPrice > 0 ? atr_val / typicalPrice : na
    else
        na

//@function ATR Percentage - ATR as percentage of close
//@param length Period for ATR calculation
//@returns ATRP value as percentage
export atrp(simple int length) =>
    if length <= 0
        runtime.error("Period must be greater than 0")
    var float prevClose = close
    float tr1 = high - low
    float tr2 = math.abs(high - prevClose)
    float tr3 = math.abs(low - prevClose)
    float trueRange = math.max(tr1, tr2, tr3)
    prevClose := close
    float alpha = 1.0 / float(length)
    float beta = 1.0 - alpha
    var float EPSILON = 1e-10
    var float raw_rma = 0.0
    var float e = 1.0
    if not na(trueRange)
        raw_rma := (raw_rma * (length - 1) + trueRange) / length
        e *= beta
        float atr_val = e > EPSILON ? raw_rma / (1.0 - e) : raw_rma
        close > 0 ? (atr_val / close) * 100 : na
    else
        na

//@function Average Daily Range - mean of daily high-low ranges
//@param length Period for ADR calculation
//@returns ADR value
export adr(simple int length) =>
    if length <= 0
        runtime.error("Period must be greater than 0")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum = 0.0
    var int count = 0
    float dailyRange = high - low
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
    else
        count += 1
    float current = nz(dailyRange)
    sum += current
    array.set(buffer, head, current)
    head := (head + 1) % length
    sum / math.max(1, count)

// =============================================================================
// LOG RETURN VOLATILITY
// =============================================================================

//@function Historical Volatility - standard deviation of log returns
//@param src_price Source series
//@param length_hv Period for standard deviation
//@param annualize Annualize the volatility
//@param annualPeriods Periods per year for annualization
//@returns HV value
export hv(series float src_price, simple int length_hv, simple bool annualize = true, simple int annualPeriods = 252) =>
    if length_hv <= 1
        runtime.error("Length for HV must be greater than 1")
    if annualize and annualPeriods <= 0
        runtime.error("Annual periods must be greater than 0 if annualizing")
    var array<float> _buffer_hv = array.new_float(length_hv, na)
    var int _head_idx_hv = 0
    var int _current_fill_count_hv = 0
    var float _sum_val_hv = 0.0
    var float _sum_sq_val_hv = 0.0
    float logReturn = na(src_price[1]) or src_price[1] == 0 ? na : math.log(src_price / nz(src_price[1], src_price))
    float stdDevLogReturns = na
    if not na(logReturn)
        float _oldest_val_in_buffer_hv = array.get(_buffer_hv, _head_idx_hv)
        if not na(_oldest_val_in_buffer_hv)
            _sum_val_hv -= _oldest_val_in_buffer_hv
            _sum_sq_val_hv -= _oldest_val_in_buffer_hv * _oldest_val_in_buffer_hv
            _current_fill_count_hv -= 1
        float _current_log_return_val = nz(logReturn)
        _sum_val_hv += _current_log_return_val
        _sum_sq_val_hv += _current_log_return_val * _current_log_return_val
        _current_fill_count_hv += 1
        array.set(_buffer_hv, _head_idx_hv, _current_log_return_val)
        _head_idx_hv := (_head_idx_hv + 1) % length_hv
        if _current_fill_count_hv > 1
            float _variance_hv = (_sum_sq_val_hv / _current_fill_count_hv) - math.pow(_sum_val_hv / _current_fill_count_hv, 2)
            stdDevLogReturns := math.sqrt(math.max(0.0, _variance_hv))
        else
            stdDevLogReturns := 0.0
    else
        stdDevLogReturns := na
    float volatility = stdDevLogReturns
    if annualize and not na(volatility)
        volatility := volatility * math.sqrt(float(annualPeriods))
    volatility

//@function Realized Volatility - similar to HV with different calculation
//@param src_price Source series
//@param length_rv Period for realized volatility
//@param annualize Annualize the volatility
//@param annualPeriods Periods per year
//@returns RV value
export rv(series float src_price, simple int length_rv, simple bool annualize = true, simple int annualPeriods = 252) =>
    if length_rv <= 1
        runtime.error("Length for RV must be greater than 1")
    if annualize and annualPeriods <= 0
        runtime.error("Annual periods must be greater than 0 if annualizing")
    var array<float> _buffer_rv = array.new_float(length_rv, na)
    var int _head_idx_rv = 0
    var int _current_fill_count_rv = 0
    var float _sum_sq_val_rv = 0.0
    float logReturn = na(src_price[1]) or src_price[1] == 0 ? na : math.log(src_price / nz(src_price[1], src_price))
    float realizedVol = na
    if not na(logReturn)
        float _oldest_val_in_buffer_rv = array.get(_buffer_rv, _head_idx_rv)
        if not na(_oldest_val_in_buffer_rv)
            _sum_sq_val_rv -= _oldest_val_in_buffer_rv * _oldest_val_in_buffer_rv
            _current_fill_count_rv -= 1
        float _current_log_return_val = nz(logReturn)
        _sum_sq_val_rv += _current_log_return_val * _current_log_return_val
        _current_fill_count_rv += 1
        array.set(_buffer_rv, _head_idx_rv, _current_log_return_val)
        _head_idx_rv := (_head_idx_rv + 1) % length_rv
        if _current_fill_count_rv > 0
            realizedVol := math.sqrt(_sum_sq_val_rv / _current_fill_count_rv)
        else
            realizedVol := 0.0
    else
        realizedVol := na
    float volatility = realizedVol
    if annualize and not na(volatility)
        volatility := volatility * math.sqrt(float(annualPeriods))
    volatility

//@function Rogers-Satchell Volatility - high-low-open-close volatility
//@param length Period for RSV
//@param annualize Annualize the volatility
//@param annualPeriods Periods per year
//@returns RSV value
export rsv(simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum_sq = 0.0
    var int count = 0
    float hl = high > 0 and close > 0 ? math.log(high / close) : 0.0
    float lc = low > 0 and close > 0 ? math.log(low / close) : 0.0
    float ho = high > 0 and open > 0 ? math.log(high / open) : 0.0
    float lo = low > 0 and open > 0 ? math.log(low / open) : 0.0
    float rs = hl * lc + ho * lo
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum_sq -= oldest
    else
        count += 1
    float current = nz(rs)
    sum_sq += current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float variance = sum_sq / math.max(1, count)
    float rsv_val = math.sqrt(math.max(0.0, variance))
    annualize ? rsv_val * math.sqrt(float(annualPeriods)) : rsv_val

//@function Garman-Klass Volatility - OHLC-based volatility
//@param length Period for GKV
//@param annualize Annualize the volatility
//@param annualPeriods Periods per year
//@returns GKV value
export gkv(simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum = 0.0
    var int count = 0
    float hl_log = high > 0 and low > 0 ? math.log(high / low) : 0.0
    float co_log = close > 0 and open > 0 ? math.log(close / open) : 0.0
    float gk_component = 0.5 * hl_log * hl_log - (2 * math.log(2) - 1) * co_log * co_log
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
    else
        count += 1
    float current = nz(gk_component)
    sum += current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float variance = sum / math.max(1, count)
    float gkv_val = math.sqrt(math.max(0.0, variance))
    annualize ? gkv_val * math.sqrt(float(annualPeriods)) : gkv_val

//@function Yang-Zhang Volatility - complete OHLC volatility
//@param length Period for YZV
//@param annualize Annualize the volatility
//@param annualPeriods Periods per year
//@returns YZV value
export yzv(simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum = 0.0
    var int count = 0
    float prevClose = nz(close[1], close)
    float co_log = prevClose > 0 and open > 0 ? math.log(open / prevClose) : 0.0
    float oc_log = close > 0 and open > 0 ? math.log(close / open) : 0.0
    float ou_log = high > 0 and open > 0 ? math.log(high / open) : 0.0
    float ol_log = low > 0 and open > 0 ? math.log(low / open) : 0.0
    float k = 0.34 / (1.34 + (length + 1.0) / (length - 1.0))
    float yz_component = (ou_log * (ou_log - oc_log) + ol_log * (ol_log - oc_log)) - k * co_log * co_log
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
    else
        count += 1
    float current = nz(yz_component)
    sum += current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float variance = sum / math.max(1, count)
    float yzv_val = math.sqrt(math.max(0.0, variance))
    annualize ? yzv_val * math.sqrt(float(annualPeriods)) : yzv_val

//@function High-Low Volatility - simple HL range volatility
//@param length Period for HLV
//@param annualize Annualize the volatility
//@param annualPeriods Periods per year
//@returns HLV value
export hlv(simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum_sq = 0.0
    var int count = 0
    float hl_log = high > 0 and low > 0 ? math.log(high / low) : 0.0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum_sq -= oldest * oldest
    else
        count += 1
    float current = nz(hl_log)
    sum_sq += current * current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float variance = sum_sq / math.max(1, count)
    float hlv_val = math.sqrt(math.max(0.0, variance)) / (2 * math.sqrt(math.log(2)))
    annualize ? hlv_val * math.sqrt(float(annualPeriods)) : hlv_val

//@function Parkinson Volatility - high-low based estimator
//@param length Period for PV
//@param annualize Annualize the volatility
//@param annualPeriods Periods per year
//@returns PV value
export pv(simple int length, simple bool annualize = true, simple int annualPeriods = 252) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum_sq = 0.0
    var int count = 0
    float hl_log = high > 0 and low > 0 ? math.log(high / low) : 0.0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum_sq -= oldest * oldest
    else
        count += 1
    float current = nz(hl_log)
    sum_sq += current * current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float variance = sum_sq / (4 * length * math.log(2))
    float pv_val = math.sqrt(math.max(0.0, variance))
    annualize ? pv_val * math.sqrt(float(annualPeriods)) : pv_val

// =============================================================================
// VOLATILITY INDICES AND RATIOS
// =============================================================================

//@function Relative Volatility Index - RSI applied to volatility
//@param length Period for RVI
//@param std_length Period for standard deviation
//@returns RVI value
export rvi(simple int length, simple int std_length) =>
    if length <= 0 or std_length <= 0
        runtime.error("Periods must be greater than 0")
    var array<float> std_buffer = array.new_float(std_length, na)
    var int std_head = 0
    var float std_sum = 0.0
    var float std_sum_sq = 0.0
    var int std_count = 0
    float oldest_std = array.get(std_buffer, std_head)
    if not na(oldest_std)
        std_sum -= oldest_std
        std_sum_sq -= oldest_std * oldest_std
    else
        std_count += 1
    float current_std = nz(close)
    std_sum += current_std
    std_sum_sq += current_std * current_std
    array.set(std_buffer, std_head, current_std)
    std_head := (std_head + 1) % std_length
    float variance = std_count > 1 ? (std_sum_sq / std_count) - math.pow(std_sum / std_count, 2) : 0.0
    float std_dev = math.sqrt(math.max(0.0, variance))
    float alpha = 1.0 / length
    var float avg_up = 0.0
    var float avg_down = 0.0
    float change = std_dev - nz(std_dev[1])
    float up = change > 0 ? change : 0
    float down = change < 0 ? -change : 0
    avg_up := alpha * up + (1 - alpha) * nz(avg_up[1])
    avg_down := alpha * down + (1 - alpha) * nz(avg_down[1])
    float rs = avg_down > 0 ? avg_up / avg_down : 0
    100 - (100 / (1 + rs))

//@function Close Volatility - simple close-based volatility
//@param length Period for CV
//@returns CV value
export cv(simple int length) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum = 0.0
    var float sum_sq = 0.0
    var int count = 0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
        sum_sq -= oldest * oldest
    else
        count += 1
    float current = nz(close)
    sum += current
    sum_sq += current * current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float mean = sum / math.max(1, count)
    float variance = (sum_sq / math.max(1, count)) - mean * mean
    math.sqrt(math.max(0.0, variance))

//@function Chaikin Volatility - rate of change in ATR
//@param length Period for EMA of HL range
//@param roc_length Period for rate of change
//@returns CCV value
export ccv(simple int length, simple int roc_length) =>
    if length <= 0 or roc_length <= 0
        runtime.error("Periods must be greater than 0")
    float hl_range = high - low
    float alpha = 2.0 / (length + 1)
    var float ema_hl = 0.0
    ema_hl := alpha * (hl_range - ema_hl) + ema_hl
    float ema_hl_roc = nz(ema_hl[roc_length])
    ema_hl_roc > 0 ? ((ema_hl - ema_hl_roc) / ema_hl_roc) * 100 : 0.0

//@function Coefficient of Variation Index - normalized volatility
//@param length Period for CVI
//@returns CVI value
export cvi(simple int length) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum = 0.0
    var float sum_sq = 0.0
    var int count = 0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
        sum_sq -= oldest * oldest
    else
        count += 1
    float current = nz(close)
    sum += current
    sum_sq += current * current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float mean = sum / math.max(1, count)
    float variance = (sum_sq / math.max(1, count)) - mean * mean
    float std_dev = math.sqrt(math.max(0.0, variance))
    mean > 0 ? (std_dev / mean) * 100 : 0.0

//@function Volatility Ratio - short/long volatility ratio
//@param short_length Short period
//@param long_length Long period
//@returns VR value
export vr(simple int short_length, simple int long_length) =>
    if short_length <= 0 or long_length <= 0
        runtime.error("Periods must be greater than 0")
    if short_length >= long_length
        runtime.error("Short period must be less than long period")
    var array<float> short_buffer = array.new_float(short_length, na)
    var int short_head = 0
    var float short_sum = 0.0
    var float short_sum_sq = 0.0
    var int short_count = 0
    var array<float> long_buffer = array.new_float(long_length, na)
    var int long_head = 0
    var float long_sum = 0.0
    var float long_sum_sq = 0.0
    var int long_count = 0
    float oldest_short = array.get(short_buffer, short_head)
    if not na(oldest_short)
        short_sum -= oldest_short
        short_sum_sq -= oldest_short * oldest_short
    else
        short_count += 1
    float oldest_long = array.get(long_buffer, long_head)
    if not na(oldest_long)
        long_sum -= oldest_long
        long_sum_sq -= oldest_long * oldest_long
    else
        long_count += 1
    float current = nz(close)
    short_sum += current
    short_sum_sq += current * current
    array.set(short_buffer, short_head, current)
    short_head := (short_head + 1) % short_length
    long_sum += current
    long_sum_sq += current * current
    array.set(long_buffer, long_head, current)
    long_head := (long_head + 1) % long_length
    float short_mean = short_sum / math.max(1, short_count)
    float short_variance = (short_sum_sq / math.max(1, short_count)) - short_mean * short_mean
    float short_std = math.sqrt(math.max(0.0, short_variance))
    float long_mean = long_sum / math.max(1, long_count)
    float long_variance = (long_sum_sq / math.max(1, long_count)) - long_mean * long_mean
    float long_std = math.sqrt(math.max(0.0, long_variance))
    long_std > 0 ? short_std / long_std : 1.0

//@function Volatility of Volatility - volatility of HV
//@param length Period for HV
//@param vov_length Period for VOV
//@returns VOV value
export vov(simple int length, simple int vov_length) =>
    if length <= 1 or vov_length <= 1
        runtime.error("Lengths must be greater than 1")
    var array<float> hv_buffer = array.new_float(length, na)
    var int hv_head = 0
    var float hv_sum = 0.0
    var float hv_sum_sq = 0.0
    var int hv_count = 0
    float logReturn = na(close[1]) or close[1] == 0 ? na : math.log(close / nz(close[1], close))
    if not na(logReturn)
        float oldest_hv = array.get(hv_buffer, hv_head)
        if not na(oldest_hv)
            hv_sum -= oldest_hv
            hv_sum_sq -= oldest_hv * oldest_hv
        else
            hv_count += 1
        float current_hv = nz(logReturn)
        hv_sum += current_hv
        hv_sum_sq += current_hv * current_hv
        array.set(hv_buffer, hv_head, current_hv)
        hv_head := (hv_head + 1) % length
    float hv_variance = hv_count > 1 ? (hv_sum_sq / hv_count) - math.pow(hv_sum / hv_count, 2) : 0.0
    float hv_val = math.sqrt(math.max(0.0, hv_variance))
    var array<float> vov_buffer = array.new_float(vov_length, na)
    var int vov_head = 0
    var float vov_sum = 0.0
    var float vov_sum_sq = 0.0
    var int vov_count = 0
    float oldest_vov = array.get(vov_buffer, vov_head)
    if not na(oldest_vov)
        vov_sum -= oldest_vov
        vov_sum_sq -= oldest_vov * oldest_vov
    else
        vov_count += 1
    float current_vov = nz(hv_val)
    vov_sum += current_vov
    vov_sum_sq += current_vov * current_vov
    array.set(vov_buffer, vov_head, current_vov)
    vov_head := (vov_head + 1) % vov_length
    float vov_mean = vov_sum / math.max(1, vov_count)
    float vov_variance = (vov_sum_sq / math.max(1, vov_count)) - vov_mean * vov_mean
    math.sqrt(math.max(0.0, vov_variance))

// =============================================================================
// BOLLINGER BAND VOLATILITY
// =============================================================================

//@function Bollinger Band Width - width between bands
//@param length Period for BB
//@param mult Standard deviation multiplier
//@returns BBW value
export bbw(simple int length, simple float mult = 2.0) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum = 0.0
    var float sum_sq = 0.0
    var int count = 0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
        sum_sq -= oldest * oldest
    else
        count += 1
    float current = nz(close)
    sum += current
    sum_sq += current * current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float mean = sum / math.max(1, count)
    float variance = (sum_sq / math.max(1, count)) - mean * mean
    float std_dev = math.sqrt(math.max(0.0, variance))
    float upper = mean + mult * std_dev
    float lower = mean - mult * std_dev
    upper - lower

//@function Bollinger Band Width Normalized - BBW as % of middle band
//@param length Period for BB
//@param mult Standard deviation multiplier
//@returns BBWN value
export bbwn(simple int length, simple float mult = 2.0) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum = 0.0
    var float sum_sq = 0.0
    var int count = 0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
        sum_sq -= oldest * oldest
    else
        count += 1
    float current = nz(close)
    sum += current
    sum_sq += current * current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float mean = sum / math.max(1, count)
    float variance = (sum_sq / math.max(1, count)) - mean * mean
    float std_dev = math.sqrt(math.max(0.0, variance))
    float upper = mean + mult * std_dev
    float lower = mean - mult * std_dev
    float width = upper - lower
    mean > 0 ? (width / mean) * 100 : 0.0

//@function Bollinger Band Width Percentage - BBW as % position
//@param length Period for BB
//@param mult Standard deviation multiplier
//@returns BBWP value
export bbwp(simple int length, simple float mult = 2.0) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum = 0.0
    var float sum_sq = 0.0
    var int count = 0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
        sum_sq -= oldest * oldest
    else
        count += 1
    float current = nz(close)
    sum += current
    sum_sq += current * current
    array.set(buffer, head, current)
    head := (head + 1) % length
    float mean = sum / math.max(1, count)
    float variance = (sum_sq / math.max(1, count)) - mean * mean
    float std_dev = math.sqrt(math.max(0.0, variance))
    float upper = mean + mult * std_dev
    float lower = mean - mult * std_dev
    float width = upper - lower
    width > 0 ? ((close - lower) / width) * 100 : 50.0

// =============================================================================
// SPECIALIZED VOLATILITY INDICATORS
// =============================================================================

//@function Ulcer Index - downside volatility measure
//@param length Period for UI
//@returns UI value
export ui(simple int length) =>
    if length <= 1
        runtime.error("Length must be greater than 1")
    var float highest_close = close
    var array<float> buffer = array.new_float(length, na)
    var int head = 0
    var float sum_sq = 0.0
    var int count = 0
    highest_close := math.max(highest_close, close)
    float drawdown = highest_close > 0 ? ((close - highest_close) / highest_close) * 100 : 0.0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum_sq -= oldest * oldest
    else
        count += 1
    float current = nz(drawdown)
    sum_sq += current * current
    array.set(buffer, head, current)
    head := (head + 1) % length
    math.sqrt(sum_sq / math.max(1, count))

//@function Mass Index - volatility expansion indicator
//@param length Period for EMA
//@param sum_length Period for sum
//@returns MASSI value
export massi(simple int length, simple int sum_length) =>
    if length <= 0 or sum_length <= 0
        runtime.error("Periods must be greater than 0")
    float hl = high - low
    float alpha = 2.0 / (length + 1)
    var float ema1 = 0.0
    var float ema2 = 0.0
    ema1 := alpha * (hl - ema1) + ema1
    ema2 := alpha * (ema1 - ema2) + ema2
    float ratio = ema2 > 0 ? ema1 / ema2 : 1.0
    var array<float> buffer = array.new_float(sum_length, na)
    var int head = 0
    var float sum = 0.0
    var int count = 0
    float oldest = array.get(buffer, head)
    if not na(oldest)
        sum -= oldest
    else
        count += 1
    float current = nz(ratio)
    sum += current
    array.set(buffer, head, current)
    head := (head + 1) % sum_length
    sum

//@function Exponentially Weighted Moving Average Volatility - EWMA variance
//@param length Period for EWMA
//@param lambda Decay factor
//@returns EWMA volatility value
export ewma(simple int length, simple float lambda = 0.94) =>
    if length <= 0
        runtime.error("Length must be greater than 0")
    if lambda < 0 or lambda > 1
        runtime.error("Lambda must be between 0 and 1")
    float logReturn = na(close[1]) or close[1] == 0 ? na : math.log(close / nz(close[1], close))
    var float ewma_variance = 0.0
    if not na(logReturn)
        float squared_return = logReturn * logReturn
        ewma_variance := lambda * ewma_variance + (1 - lambda) * squared_return
    math.sqrt(math.max(0.0, ewma_variance))

//@function Jurik Volatility - Jurik's adaptive volatility
//@param length Period for volatility
//@param power Smoothing power
//@returns JVolty value
export jvolty(simple int length, simple float power = 1.0) =>
    if length <= 0
        runtime.error("Length must be greater than 0")
    float hl = high - low
    float hc = math.abs(high - nz(close[1]))
    float lc = math.abs(low - nz(close[1]))
    float tr = math.max(hl, math.max(hc, lc))
    float beta = power * (length - 1) / ((power * (length - 1)) + 2)
    var float volty = 0.0
    volty := beta * volty + (1 - beta) * tr
    volty

//@function Jurik Volatility Normalized - JVolty as % of price
//@param length Period for volatility
//@param power Smoothing power
//@returns JVoltyN value
export jvoltyn(simple int length, simple float power = 1.0) =>
    if length <= 0
        runtime.error("Length must be greater than 0")
    float hl = high - low
    float hc = math.abs(high - nz(close[1]))
    float lc = math.abs(low - nz(close[1]))
    float tr = math.max(hl, math.max(hc, lc))
    float beta = power * (length - 1) / ((power * (length - 1)) + 2)
    var float volty = 0.0
    volty := beta * volty + (1 - beta) * tr
    close > 0 ? (volty / close) * 100 : 0.0
