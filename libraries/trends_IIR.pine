// The MIT License (MIT)
// Â© mihakralj
//@version=6
//@description Library of IIR (Infinite Impulse Response) trend filters - 23 self-contained moving averages with no external dependencies

library("trends_IIR", overlay=true)

// =============================================================================
// BASIC EXPONENTIAL SMOOTHING
// =============================================================================

//@function Exponential Moving Average - exponential weighting with O(1) complexity
//@param source Series to calculate EMA from
//@param period Lookback period
//@returns EMA value from first bar
export ema(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    float alpha = 2.0 / (period + 1)
    float beta = 1.0 - alpha
    var bool warmup = true
    var float e = 1.0
    var float ema = 0.0
    var float result = source
    ema := alpha * (source - ema) + ema
    if warmup
        e *= beta
        float c = 1.0 / (1.0 - e)
        result := c * ema
        warmup := e > 1e-10
    else
        result := ema
    result

//@function Wilder's Moving Average (RMA) - Wilder's smoothing method
//@param source Series to calculate RMA from
//@param period Lookback period
//@returns RMA value from first bar
export rma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    float alpha = 1.0 / period
    float beta = 1.0 - alpha
    var bool warmup = true
    var float e = 1.0
    var float rma = 0.0
    var float result = source
    rma := alpha * (source - rma) + rma
    if warmup
        e *= beta
        float c = 1.0 / (1.0 - e)
        result := c * rma
        warmup := e > 1e-10
    else
        result := rma
    result

// =============================================================================
// CASCADED EXPONENTIAL SMOOTHING
// =============================================================================

//@function Double Exponential Moving Average - two-pass EMA
//@param source Series to calculate DEMA from
//@param period Lookback period
//@returns DEMA value from first bar
export dema(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    float alpha = 2.0 / (period + 1)
    float beta = 1.0 - alpha
    var bool warmup = true
    var float e = 1.0
    var float ema1 = 0.0
    var float ema2 = 0.0
    var float result = source
    ema1 := alpha * (source - ema1) + ema1
    ema2 := alpha * (ema1 - ema2) + ema2
    if warmup
        e *= beta
        float c = 1.0 / (1.0 - e)
        result := 2.0 * (c * ema1) - (c * ema2)
        warmup := e > 1e-10
    else
        result := 2.0 * ema1 - ema2
    result

//@function Triple Exponential Moving Average - three-pass EMA
//@param source Series to calculate TEMA from
//@param period Lookback period
//@returns TEMA value from first bar
export tema(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    float alpha = 2.0 / (period + 1)
    float beta1 = 1.0 - alpha
    float beta2 = 1.0 - alpha
    float beta3 = 1.0 - alpha
    var bool warmup = true
    var float e1 = 1.0
    var float e2 = 1.0
    var float e3 = 1.0
    var float ema1 = 0.0
    var float ema2 = 0.0
    var float ema3 = 0.0
    var float result = source
    ema1 := alpha * (source - ema1) + ema1
    ema2 := alpha * (ema1 - ema2) + ema2
    ema3 := alpha * (ema2 - ema3) + ema3
    if warmup
        e1 *= beta1
        e2 *= beta2
        e3 *= beta3
        float c1 = 1.0 / (1.0 - e1)
        float c2 = 1.0 / (1.0 - e2)
        float c3 = 1.0 / (1.0 - e3)
        result := 3.0 * (c1 * ema1) - 3.0 * (c2 * ema2) + (c3 * ema3)
        warmup := e1 > 1e-10 or e2 > 1e-10 or e3 > 1e-10
    else
        result := 3.0 * ema1 - 3.0 * ema2 + ema3
    result

//@function Quadruple Exponential Moving Average - four-pass EMA
//@param source Series to calculate QEMA from
//@param period Lookback period
//@returns QEMA value from first bar
export qema(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    float alpha = 2.0 / (period + 1)
    float beta1 = 1.0 - alpha
    float beta2 = 1.0 - alpha
    float beta3 = 1.0 - alpha
    float beta4 = 1.0 - alpha
    var bool warmup = true
    var float e1 = 1.0
    var float e2 = 1.0
    var float e3 = 1.0
    var float e4 = 1.0
    var float ema1 = 0.0
    var float ema2 = 0.0
    var float ema3 = 0.0
    var float ema4 = 0.0
    var float result = source
    ema1 := alpha * (source - ema1) + ema1
    ema2 := alpha * (ema1 - ema2) + ema2
    ema3 := alpha * (ema2 - ema3) + ema3
    ema4 := alpha * (ema3 - ema4) + ema4
    if warmup
        e1 *= beta1
        e2 *= beta2
        e3 *= beta3
        e4 *= beta4
        float c1 = 1.0 / (1.0 - e1)
        float c2 = 1.0 / (1.0 - e2)
        float c3 = 1.0 / (1.0 - e3)
        float c4 = 1.0 / (1.0 - e4)
        result := 4.0 * (c1 * ema1) - 6.0 * (c2 * ema2) + 4.0 * (c3 * ema3) - (c4 * ema4)
        warmup := e1 > 1e-10 or e2 > 1e-10 or e3 > 1e-10 or e4 > 1e-10
    else
        result := 4.0 * ema1 - 6.0 * ema2 + 4.0 * ema3 - ema4
    result

// =============================================================================
// ZERO-LAG EXPONENTIAL SMOOTHING
// =============================================================================

//@function Zero-Lag Exponential Moving Average - lag-compensated EMA
//@param source Series to calculate ZLEMA from
//@param period Lookback period
//@returns ZLEMA value from first bar
export zlema(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int lag = math.round((period - 1) / 2)
    float alpha = 2.0 / (period + 1)
    float beta = 1.0 - alpha
    var bool warmup = true
    var float e = 1.0
    var float ema = 0.0
    var array<float> buffer = array.new_float(lag + 1, na)
    var int head = 0
    var float result = source
    float lagged = array.get(buffer, head)
    float adjusted = not na(lagged) ? 2.0 * source - lagged : source
    array.set(buffer, head, source)
    head := (head + 1) % (lag + 1)
    ema := alpha * (adjusted - ema) + ema
    if warmup
        e *= beta
        float c = 1.0 / (1.0 - e)
        result := c * ema
        warmup := e > 1e-10
    else
        result := ema
    result

//@function Zero-Lag Double Exponential Moving Average
//@param source Series to calculate ZLDEMA from
//@param period Lookback period
//@returns ZLDEMA value from first bar
export zldema(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int lag = math.round((period - 1) / 2)
    float alpha = 2.0 / (period + 1)
    float beta = 1.0 - alpha
    var bool warmup = true
    var float e = 1.0
    var float ema1 = 0.0
    var float ema2 = 0.0
    var array<float> buffer = array.new_float(lag + 1, na)
    var int head = 0
    var float result = source
    float lagged = array.get(buffer, head)
    float adjusted = not na(lagged) ? 2.0 * source - lagged : source
    array.set(buffer, head, source)
    head := (head + 1) % (lag + 1)
    ema1 := alpha * (adjusted - ema1) + ema1
    ema2 := alpha * (ema1 - ema2) + ema2
    if warmup
        e *= beta
        float c = 1.0 / (1.0 - e)
        result := 2.0 * (c * ema1) - (c * ema2)
        warmup := e > 1e-10
    else
        result := 2.0 * ema1 - ema2
    result

//@function Zero-Lag Triple Exponential Moving Average
//@param source Series to calculate ZLTEMA from
//@param period Lookback period
//@returns ZLTEMA value from first bar
export zltema(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int lag = math.round((period - 1) / 2)
    float alpha = 2.0 / (period + 1)
    float beta1 = 1.0 - alpha
    float beta2 = 1.0 - alpha
    float beta3 = 1.0 - alpha
    var bool warmup = true
    var float e1 = 1.0
    var float e2 = 1.0
    var float e3 = 1.0
    var float ema1 = 0.0
    var float ema2 = 0.0
    var float ema3 = 0.0
    var array<float> buffer = array.new_float(lag + 1, na)
    var int head = 0
    var float result = source
    float lagged = array.get(buffer, head)
    float adjusted = not na(lagged) ? 2.0 * source - lagged : source
    array.set(buffer, head, source)
    head := (head + 1) % (lag + 1)
    ema1 := alpha * (adjusted - ema1) + ema1
    ema2 := alpha * (ema1 - ema2) + ema2
    ema3 := alpha * (ema2 - ema3) + ema3
    if warmup
        e1 *= beta1
        e2 *= beta2
        e3 *= beta3
        float c1 = 1.0 / (1.0 - e1)
        float c2 = 1.0 / (1.0 - e2)
        float c3 = 1.0 / (1.0 - e3)
        result := 3.0 * (c1 * ema1) - 3.0 * (c2 * ema2) + (c3 * ema3)
        warmup := e1 > 1e-10 or e2 > 1e-10 or e3 > 1e-10
    else
        result := 3.0 * ema1 - 3.0 * ema2 + ema3
    result

// =============================================================================
// COMPOSITE EXPONENTIAL SMOOTHING
// =============================================================================

//@function Hull-Style Exponential Moving Average
//@param source Series to calculate HEMA from
//@param period Lookback period
//@returns HEMA value from first bar
export hema(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int halfPeriod = math.max(1, math.round(period / 2))
    int sqrtPeriod = math.max(1, math.round(math.sqrt(period)))
    float alphaSlow = 2.0 / (period + 1)
    float alphaFast = 2.0 / (halfPeriod + 1)
    float alphaSmooth = 2.0 / (sqrtPeriod + 1)
    float betaSlow = 1.0 - alphaSlow
    float betaFast = 1.0 - alphaFast
    float betaSmooth = 1.0 - alphaSmooth
    var bool warmupSlow = true
    var bool warmupFast = true
    var bool warmupSmooth = true
    var float decaySlow = 1.0
    var float decayFast = 1.0
    var float decaySmooth = 1.0
    var float emaSlow = 0.0
    var float emaFast = 0.0
    var float emaSmooth = 0.0
    var float resultSlow = source
    var float resultFast = source
    var float resultSmooth = source
    emaSlow := alphaSlow * (source - emaSlow) + emaSlow
    if warmupSlow
        decaySlow *= betaSlow
        float cSlow = 1.0 / (1.0 - decaySlow)
        resultSlow := cSlow * emaSlow
        warmupSlow := decaySlow > 1e-10
    else
        resultSlow := emaSlow
    emaFast := alphaFast * (source - emaFast) + emaFast
    if warmupFast
        decayFast *= betaFast
        float cFast = 1.0 / (1.0 - decayFast)
        resultFast := cFast * emaFast
        warmupFast := decayFast > 1e-10
    else
        resultFast := emaFast
    float diff = 2.0 * resultFast - resultSlow
    emaSmooth := alphaSmooth * (diff - emaSmooth) + emaSmooth
    if warmupSmooth
        decaySmooth *= betaSmooth
        float cSmooth = 1.0 / (1.0 - decaySmooth)
        resultSmooth := cSmooth * emaSmooth
        warmupSmooth := decaySmooth > 1e-10
    else
        resultSmooth := emaSmooth
    resultSmooth

// =============================================================================
// VOLATILITY-ADAPTIVE EXPONENTIAL SMOOTHING
// =============================================================================

//@function Volume-Adjusted Moving Average - ATR-based adaptive smoothing
//@param source Series to calculate VAMA from
//@param period Lookback period for both EMA and ATR
//@returns VAMA value from first bar
export vama(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int atr_short = math.max(1, math.round(period / 5))
    int atr_long = period
    float alpha_short = 2.0 / (atr_short + 1)
    float alpha_long = 2.0 / (atr_long + 1)
    float beta_short = 1.0 - alpha_short
    float beta_long = 1.0 - alpha_long
    float alpha = 2.0 / (period + 1)
    var float atr_short_state = 0.0
    var float atr_long_state = 0.0
    var float e_short = 1.0
    var float e_long = 1.0
    var bool warmup_short = true
    var bool warmup_long = true
    var float vama = na
    float tr = math.max(high - low, math.max(math.abs(high - nz(close[1])), math.abs(low - nz(close[1]))))
    atr_short_state := alpha_short * (tr - atr_short_state) + atr_short_state
    atr_long_state := alpha_long * (tr - atr_long_state) + atr_long_state
    float atr_short_val = atr_short_state
    float atr_long_val = atr_long_state
    if warmup_short
        e_short := beta_short * e_short
        float c_short = 1.0 / (1.0 - e_short)
        atr_short_val := c_short * atr_short_state
        warmup_short := e_short > 1e-10
    if warmup_long
        e_long := beta_long * e_long
        float c_long = 1.0 / (1.0 - e_long)
        atr_long_val := c_long * atr_long_state
        warmup_long := e_long > 1e-10
    float vi = atr_long_val > 0 ? math.min(atr_short_val / atr_long_val, 1.0) : 1.0
    float alpha_adj = alpha * vi
    vama := na(vama) ? source : alpha_adj * source + (1.0 - alpha_adj) * vama
    vama

//@function Yang-Zhang Volatility Adjusted Moving Average
//@param source Series to calculate YZVAMA from
//@param period Lookback period
//@returns YZVAMA value from first bar
export yzvama(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    int yzv_short = math.max(1, math.round(period / 5))
    int yzv_long = period
    float rma_alpha_short = 1.0 / yzv_short
    float rma_alpha_long = 1.0 / yzv_long
    float rma_beta_short = 1.0 - rma_alpha_short
    float rma_beta_long = 1.0 - rma_alpha_long
    float alpha = 2.0 / (period + 1)
    var float yzv_short_state = 0.0
    var float yzv_long_state = 0.0
    var float e_comp_short = 1.0
    var float e_comp_long = 1.0
    var bool warmup_comp_short = true
    var bool warmup_comp_long = true
    var float yzvama = na
    float c_prev = nz(close[1])
    float o_curr = open
    float h_curr = high
    float l_curr = low
    float c_curr = close
    float co = math.log(o_curr / c_prev)
    float oc = math.log(c_curr / o_curr)
    float ou = math.log(h_curr / o_curr)
    float ol = math.log(l_curr / o_curr)
    float k = 0.34 / (1.34 + (period + 1.0) / (period - 1.0))
    float yzv_val = (ou * (ou - oc) + ol * (ol - oc)) - k * co * co
    yzv_short_state := rma_alpha_short * (yzv_val - yzv_short_state) + yzv_short_state
    yzv_long_state := rma_alpha_long * (yzv_val - yzv_long_state) + yzv_long_state
    float yzv_short_result = yzv_short_state
    float yzv_long_result = yzv_long_state
    if warmup_comp_short
        e_comp_short := rma_beta_short * e_comp_short
        float c_short = 1.0 / (1.0 - e_comp_short)
        yzv_short_result := c_short * yzv_short_state
        warmup_comp_short := e_comp_short > 1e-10
    if warmup_comp_long
        e_comp_long := rma_beta_long * e_comp_long
        float c_long = 1.0 / (1.0 - e_comp_long)
        yzv_long_result := c_long * yzv_long_state
        warmup_comp_long := e_comp_long > 1e-10
    float vi = yzv_long_result > 0 ? math.min(math.sqrt(math.max(0, yzv_short_result / yzv_long_result)), 1.0) : 1.0
    float alpha_adj = alpha * vi
    yzvama := na(yzvama) ? source : alpha_adj * source + (1.0 - alpha_adj) * yzvama
    yzvama

// =============================================================================
// ADAPTIVE ALPHA ALGORITHMS
// =============================================================================

//@function Kaufman's Adaptive Moving Average
//@param source Series to calculate KAMA from
//@param period Efficiency ratio lookback period
//@param fast_alpha Fastest EMA constant
//@param slow_alpha Slowest EMA constant
//@returns KAMA value with efficiency ratio-based adaptation
export kama(series float source, simple int period, simple float fast_alpha=0.666667, simple float slow_alpha=0.0645) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    if fast_alpha <= 0 or slow_alpha <= 0
        runtime.error("Alpha values must be greater than 0")
    if fast_alpha <= slow_alpha
        runtime.error("Fast alpha must be greater than slow alpha")
    var float kama_state = na
    float current_kama = na
    if not na(source)
        float change_val = math.abs(source - source[period])
        float volatility_val = math.sum(math.abs(source - source[1]), period)
        float er = 0.0
        if not na(change_val) and not na(volatility_val) and volatility_val != 0.0
            er := change_val / volatility_val
        float sc = math.pow(er * (fast_alpha - slow_alpha) + slow_alpha, 2)
        kama_state := na(kama_state) ? source : kama_state + sc * (source - kama_state)
        current_kama := kama_state
    current_kama

//@function Fractal Adaptive Moving Average
//@param source Series to calculate FRAMA from
//@param period Lookback period
//@returns FRAMA value with fractal dimension-based adaptation
export frama(series float src, simple int period) =>
    int p = math.max(2, period)
    int p_adj = p % 2 == 0 ? p : p + 1
    int i_h_p = int(p_adj / 2)
    float n1 = na
    float n2 = na
    float n3 = na
    bool data_available = bar_index >= (p_adj - 1) and not na(src[p_adj - 1])
    if data_available
        float hh1 = src
        float ll1 = src
        for i = 1 to i_h_p - 1
            float val = src[i]
            if not na(val)
                hh1 := math.max(hh1, val)
                ll1 := math.min(ll1, val)
        float hh2_calc = src[i_h_p]
        float ll2_calc = src[i_h_p]
        bool second_half_na = na(hh2_calc)
        if not second_half_na
            for i = i_h_p + 1 to p_adj - 1
                float val = src[i]
                if not na(val)
                    hh2_calc := math.max(hh2_calc, val)
                    ll2_calc := math.min(ll2_calc, val)
                else
                    second_half_na := true
                    break
        float hh3 = src
        float ll3 = src
        for i = 1 to p_adj - 1
            float val = src[i]
            if not na(val)
                hh3 := math.max(hh3, val)
                ll3 := math.min(ll3, val)
        if not na(hh1) and not na(ll1) and i_h_p > 0
            n1 := (hh1 - ll1) / i_h_p
        if not second_half_na and i_h_p > 0
            n2 := (hh2_calc - ll2_calc) / i_h_p
        if not na(hh3) and not na(ll3) and p_adj > 0
            n3 := (hh3 - ll3) / p_adj
    var float result = na
    float alpha = 1.0
    if n1 > 0 and n2 > 0 and n3 > 0
        float dimen = (math.log(n1 + n2) - math.log(n3)) / math.log(2.0)
        alpha := math.exp(-4.6 * (dimen - 1.0))
        alpha := math.max(0.01, math.min(1.0, alpha))
    if not na(src)
        float prev_f = nz(result[1], src)
        result := alpha * src + (1.0 - alpha) * prev_f
    else
        result := na
    data_available ? result : na

//@function Variable Index Dynamic Average
//@param source Series to calculate VIDYA from
//@param period Smoothing period
//@param std_period Standard deviation period
//@returns VIDYA value with volatility-based adaptation
export vidya(series float source, simple int period, simple int std_period=0) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    float alpha = 2.0 / (period + 1.0)
    var float vidya = na
    if not na(source)
        int p = std_period > 0 ? std_period : period
        float sum_p = 0.0
        float sumSq_p = 0.0
        float count_p = 0.0
        float sum_5 = 0.0
        float sumSq_5 = 0.0
        float count_5 = 0.0
        for i = 0 to math.max(p, 5) - 1
            if not na(source[i])
                float val = source[i]
                if i < p
                    sum_p += val
                    sumSq_p += val * val
                    count_p += 1
                if i < 5
                    sum_5 += val
                    sumSq_5 += val * val
                    count_5 += 1
        float std = count_p > 0 ? math.sqrt(math.max((sumSq_p / count_p) - (sum_p / count_p) * (sum_p / count_p), 0.0)) : 0.0
        float std_5 = count_5 > 0 ? math.sqrt(math.max((sumSq_5 / count_5) - (sum_5 / count_5) * (sum_5 / count_5), 0.0)) : 0.0
        float vol_idx = std > 0 ? std_5 / std : 1.0
        vol_idx := math.min(math.max(vol_idx, 0.0), 1.0)
        float sc = alpha * vol_idx
        vidya := na(vidya) ? source : source * sc + vidya * (1.0 - sc)
    vidya

//@function Deviation-Scaled Moving Average
//@param source Series to calculate DSMA from
//@param period Lookback period
//@param scaleFactor Scaling/smoothing factor
//@returns DSMA value with deviation-based adaptation
export dsma(series float source, simple int period, simple float scaleFactor=0.5) =>
    float a1 = math.exp(-1.414 * math.pi / (period * 0.5))
    float b1 = 2.0 * a1 * math.cos(1.414 * math.pi / (period * 0.5))
    float c1 = 1.0 - b1 + (a1 * a1)
    float c1Half = c1 * 0.5
    float periodRecip = 1.0 / period
    float scaleAdjustment = scaleFactor * 5.0 * periodRecip
    var float result = na
    var float filt = 0.0
    var float filt1 = 0.0
    var float filt2 = 0.0
    var float zeros1 = 0.0
    var float sumSquared = 0.0
    var array<float> filtSquared = array.new_float(period, 0.0)
    var int bufferIndex = 0
    if na(source)
        result
    else
        if na(result)
            result := source
        else
            float zeros = source - result
            filt := c1Half * (zeros + zeros1) + b1 * filt1 - (a1 * a1) * filt2
            float filtSq = filt * filt
            sumSquared := sumSquared + filtSq - array.get(filtSquared, bufferIndex)
            array.set(filtSquared, bufferIndex, filtSq)
            bufferIndex := (bufferIndex + 1) % period
            float rms = math.sqrt(math.max(sumSquared * periodRecip, 1e-10))
            float alpha = math.min(scaleAdjustment * math.abs(filt / rms), 1.0)
            result := alpha * source + (1 - alpha) * result
            zeros1 := zeros
            filt2 := filt1
            filt1 := filt
        result

// =============================================================================
// ADVANCED IIR ALGORITHMS
// =============================================================================

//@function Tillson T3 Moving Average
//@param source Series to calculate T3 from
//@param period Smoothing period
//@param v Volume factor
//@returns T3 value with six-stage EMA
export t3(series float src, simple int period, simple float v) =>
    if period <= 0
        runtime.error("T3 period must be > 0")
    float a = 2.0 / (period + 1)
    float v2 = v * v
    float v3 = v2 * v
    float c1 = -v3
    float c2 = 3.0 * (v2 + v3)
    float c3 = -3.0 * (2.0 * v2 + v + v3)
    float c4 = 1.0 + 3.0 * v + 3.0 * v2 + v3
    var float e1 = na
    var float e2 = na
    var float e3 = na
    var float e4 = na
    var float e5 = na
    var float e6 = na
    float res = na
    if not na(src)
        if na(e1)
            e1 := src
            e2 := src
            e3 := src
            e4 := src
            e5 := src
            e6 := src
            res := src
        else
            e1 := e1 + a * (src - e1)
            e2 := e2 + a * (e1 - e2)
            e3 := e3 + a * (e2 - e3)
            e4 := e4 + a * (e3 - e4)
            e5 := e5 + a * (e4 - e5)
            e6 := e6 + a * (e5 - e6)
            res := c1 * e6 + c2 * e5 + c3 * e4 + c4 * e3
    res

//@function Jurik Moving Average
//@param source Series to calculate JMA from
//@param period Lookback period
//@param phase Phase shift (-100 to 100)
//@param power Smoothing factor (0.1-1.0)
//@returns JMA value with adaptive smoothing
export jma(series float source, simple int period, simple int phase=0, simple float power=0.45) =>
    simple float PHASE_VALUE = math.min(math.max((phase * 0.01) + 1.5, 0.5), 2.5)
    simple float BETA = power * (period - 1) / ((power * (period - 1)) + 2)
    simple float LEN1 = math.max((math.log(math.sqrt(0.5 * (period - 1))) / math.log(2.0)) + 2.0, 0)
    simple float POW1 = math.max(LEN1 - 2.0, 0.5)
    simple float LEN2 = math.sqrt(0.5 * (period - 1)) * LEN1
    simple float POW1_RECIPROCAL = 1.0 / POW1
    simple float AVG_VOLTY_ALPHA = 2.0 / (math.max(4.0 * period, 65) + 1.0)
    simple float DIV = 1.0 / (10.0 + 10.0 * (math.min(math.max(period - 10, 0), 100)) / 100.0)
    var float upperBand_state = na
    var float lowerBand_state = na
    var float ma1_state = na
    var float jma_state = na
    var float vSum_state = 0.0
    var float det0_state = 0.0
    var float det1_state = 0.0
    var float avgVolty_state = na
    var array<float> volty_array_state = array.new_float(11, 0.0)
    float current_jma = na
    if not na(source)
        float del1 = source - nz(upperBand_state, source)
        float del2 = source - nz(lowerBand_state, source)
        float volty = math.abs(del1) == math.abs(del2) ? 0.0 : math.max(math.abs(del1), math.abs(del2))
        array.unshift(volty_array_state, nz(volty, 0.0))
        array.pop(volty_array_state)
        if not na(volty)
            vSum_state := vSum_state + (volty - array.get(volty_array_state, 10)) * DIV
            avgVolty_state := nz(avgVolty_state, vSum_state) + AVG_VOLTY_ALPHA * (vSum_state - nz(avgVolty_state, vSum_state))
        float rvolty = math.min(math.max(nz(avgVolty_state, 0) > 0 ? nz(volty, 0.0) / nz(avgVolty_state, 1.0) : 1.0, 1.0), math.pow(LEN1, POW1_RECIPROCAL))
        float pow2 = math.pow(rvolty, POW1)
        float Kv = math.pow(LEN2 / (LEN2 + 1), math.sqrt(pow2))
        upperBand_state := del1 > 0 ? source : source - Kv * del1
        lowerBand_state := del2 < 0 ? source : source - Kv * del2
        float alpha = math.pow(BETA, pow2)
        float alphaSquared = alpha * alpha
        float oneMinusAlpha = 1.0 - alpha
        float oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha
        ma1_state := source + (alpha * (nz(ma1_state, source) - source))
        det0_state := (source - ma1_state) * (1 - BETA) + BETA * nz(det0_state, 0)
        float ma2 = ma1_state + (PHASE_VALUE * det0_state)
        det1_state := ((ma2 - nz(jma_state, source)) * oneMinusAlphaSquared) + (alphaSquared * nz(det1_state, 0))
        jma_state := nz(jma_state, source) + det1_state
        current_jma := jma_state
    current_jma

//@function MESA Adaptive Moving Average
//@param source Series to calculate MAMA from
//@param fastLimit Maximum rate of adaptation
//@param slowLimit Minimum rate of adaptation
//@returns [mama, fama] Tuple containing MAMA and FAMA values
export mama(series float source, float fastLimit=0.5, float slowLimit=0.05) =>
    if fastLimit < slowLimit or fastLimit <= 0 or slowLimit < 0
        runtime.error("MAMA: fastLimit must be > slowLimit > 0")
    var float mama_val = na
    var float fama_val = na
    var float period = 0.0
    var float phase = 0.0
    var float smooth = na
    var float dt = na
    var float I1 = 0.0
    var float Q1 = 0.0
    var float I2 = 0.0
    var float Q2 = 0.0
    var float Re = 0.0
    var float Im = 0.0
    float TWOPI = 2.0 * math.pi
    float c1 = 0.0962
    float c2 = 0.5769
    float price = not na(source[3]) ? (4.0 * source + 3.0 * source[1] + 2.0 * source[2] + source[3]) / 10.0 : not na(source[2]) ? (4.0 * source + 3.0 * source[1] + 2.0 * source[2]) / 9.0 : not na(source[1]) ? (4.0 * source + 3.0 * source[1]) / 7.0 : source
    if na(mama_val)
        mama_val := price
        fama_val := price
        smooth := price
    else
        smooth := (4.0 * price + 3.0 * price[1] + 2.0 * price[2] + price[3]) / 10.0
        float padj = 0.075 * period + 0.54
        dt := (c1 * smooth + c2 * smooth[2] - c2 * smooth[4] - c1 * smooth[6]) * padj
        I1 := dt[3]
        Q1 := (c1 * dt + c2 * dt[2] - c2 * dt[4] - c1 * dt[6]) * padj
        float jI = (c1 * I1 + c2 * I1[2] - c2 * I1[4] - c1 * I1[6]) * padj
        float jQ = (c1 * Q1 + c2 * Q1[2] - c2 * Q1[4] - c1 * Q1[6]) * padj
        I2 := 0.2 * (I1 - jQ) + 0.8 * I2[1]
        Q2 := 0.2 * (Q1 + jI) + 0.8 * Q2[1]
        Re := 0.2 * (I2 * I2[1] + Q2 * Q2[1]) + 0.8 * Re[1]
        Im := 0.2 * (I2 * Q2[1] - Q2 * I2[1]) + 0.8 * Im[1]
        if Im != 0.0 and Re != 0.0
            period := TWOPI / math.atan(Im / Re)
        period := 0.2 * math.max(6.0, math.min(50.0, period)) + 0.8 * period[1]
        if I1 != 0.0
            phase := math.atan(Q1 / I1)
        float deltaPhase = phase[1] - phase
        if deltaPhase >= 1.0
            deltaPhase := 0.0
        if deltaPhase < 0.0
            deltaPhase += TWOPI
        float alpha = math.min(fastLimit, math.max(slowLimit, fastLimit / math.pow(deltaPhase / 0.5, 2)))
        float oneMinusAlpha = 1.0 - alpha
        mama_val := alpha * price + oneMinusAlpha * mama_val[1]
        fama_val := 0.5 * alpha * mama_val + (1.0 - 0.5 * alpha) * fama_val[1]
    [mama_val, fama_val]

//@function Hilbert Trendline
//@param source Series to calculate HTIT from
//@returns HTIT value using Hilbert Transform
export htit(series float source) =>
    var float price = na
    var float smooth = na
    var float detrender = 0.0
    var float I1 = 0.0
    var float Q1 = 0.0
    var float I2 = 0.0
    var float Q2 = 0.0
    var float Re = 0.0
    var float Im = 0.0
    var float periodEst = 10.0
    var float iTrend = na
    var float iTrend1 = na
    var float iTrend2 = na
    float result = na
    price := (4 * source + 3 * source[1] + 2 * source[2] + source[3]) / 10
    smooth := (4 * price + 3 * price[1] + 2 * price[2] + price[3]) / 10
    float padAdj = 0.075 * periodEst + 0.54
    detrender := (0.0962 * smooth + 0.5769 * smooth[2] - 0.5769 * smooth[4] - 0.0962 * smooth[6]) * padAdj
    I1 := nz(detrender[3])
    Q1 := (0.0962 * detrender + 0.5769 * detrender[2] - 0.5769 * detrender[4] - 0.0962 * detrender[6]) * padAdj
    float jI = (0.0962 * I1 + 0.5769 * I1[2] - 0.5769 * I1[4] - 0.0962 * I1[6]) * padAdj
    float jQ = (0.0962 * Q1 + 0.5769 * Q1[2] - 0.5769 * Q1[4] - 0.0962 * Q1[6]) * padAdj
    I2 := 0.2 * (I1 - jQ) + 0.8 * nz(I2[1])
    Q2 := 0.2 * (Q1 + jI) + 0.8 * nz(Q2[1])
    Re := 0.2 * (I2 * nz(I2[1]) + Q2 * nz(Q2[1])) + 0.8 * nz(Re[1])
    Im := 0.2 * (I2 * nz(Q2[1]) - Q2 * nz(I2[1])) + 0.8 * nz(Im[1])
    float newP = Im != 0 and Re != 0 ? 2 * math.pi / math.atan(Im / Re) : periodEst
    periodEst := math.max(6, math.min(50, 0.2 * newP + 0.8 * periodEst))
    float angle = I1 != 0 ? math.atan(Q1 / I1) : math.pi / 2 * math.sign(Q1)
    angle += I1 < 0 ? math.pi : Q1 < 0 and I1 > 0 ? 2 * math.pi : 0
    angle := angle % (2 * math.pi)
    float trendPower = math.sqrt(I1 * I1 + Q1 * Q1)
    float newITrendComponent = smooth + 0.07 * trendPower * math.sin(angle)
    float currentITrend2 = nz(iTrend1[1], smooth)
    float currentITrend1 = nz(iTrend[1], smooth)
    float currentITrend = 0.9 * newITrendComponent + 1.1 * currentITrend1 - 1.0 * currentITrend2
    iTrend2 := currentITrend1
    iTrend1 := currentITrend
    iTrend := currentITrend
    result := currentITrend
    result

// =============================================================================
// SPECIALIZED IIR ALGORITHMS
// =============================================================================

//@function McGinley Dynamic Indicator
//@param source Series to calculate MGDI from
//@param period Lookback period
//@param factor McGinley factor
//@returns MGDI value with dynamic factor
export mgdi(series float source, simple int period, simple float factor=0.6) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    if factor <= 0
        runtime.error("Factor must be greater than 0")
    var float mgdi_val = na
    if not na(source)
        if na(mgdi_val)
            float sum = 0.0
            int count = 0
            for i = 0 to period - 1
                if not na(source[i])
                    sum += source[i]
                    count += 1
            mgdi_val := count > 0 ? sum / count : source
        else
            if math.abs(mgdi_val) < 1e-10
                mgdi_val := source
            else
                float ratio = source / mgdi_val
                float denom = factor * period * math.pow(ratio, 4)
                denom := math.sign(denom) * math.max(0.001, math.abs(denom))
                mgdi_val := mgdi_val + (source - mgdi_val) / denom
    mgdi_val

//@function Regularized EMA
//@param source Series to calculate REMA from
//@param period Lookback period
//@param lambda Regularization parameter
//@returns REMA value with regularization
export rema(series float source, simple int period, simple float lambda=0.5) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    if lambda < 0.0 or lambda > 1.0
        runtime.error("Lambda must be between 0 and 1")
    float alpha = 2.0 / (period + 1.0)
    var float rema_val = na
    var float prev_rema = na
    float result = na
    if not na(source)
        if na(rema_val)
            rema_val := source
            prev_rema := source
            result := rema_val
        else
            prev_rema := rema_val
            float ema_component = alpha * (source - rema_val) + rema_val
            float reg_component = rema_val + (rema_val - prev_rema)
            rema_val := lambda * (ema_component - reg_component) + reg_component
            result := rema_val
    else
        result := rema_val
    result

//@function Recursive Gaussian Moving Average
//@param source Series to calculate RGMA from
//@param period Effective smoothing period
//@param passes Number of recursive passes
//@returns RGMA value with Gaussian-like smoothing
export rgma(series float source, simple int period, simple int passes=3) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    if passes <= 0
        runtime.error("Passes must be greater than 0")
    simple float alpha = 2.0 / (period / math.sqrt(passes) + 1.0)
    var array<float> filters = array.new_float(passes, na)
    float result = na
    if not na(source)
        if na(array.get(filters, 0))
            array.fill(filters, source)
            result := source
        else
            array.set(filters, 0, alpha * (source - array.get(filters, 0)) + array.get(filters, 0))
            if passes > 1
                for i = 1 to passes - 1
                    array.set(filters, i, alpha * (array.get(filters, i - 1) - array.get(filters, i)) + array.get(filters, i))
            result := array.get(filters, passes - 1)
    result

//@function Linear Time Moving Average
//@param source Series to calculate LTMA from
//@param period Lookback period
//@returns LTMA value with linear time weights
export ltma(series float source, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    float sum = 0.0
    float weight_sum = 0.0
    int count = 0
    for i = 0 to period - 1
        if not na(source[i])
            float weight = float(period - i)
            sum += source[i] * weight
            weight_sum += weight
            count += 1
    count > 0 and weight_sum > 0 ? sum / weight_sum : source

//@function Modified Moving Average
//@param source Series to calculate MMA from
//@param period Lookback period
//@returns MMA value combining SMA and weighted component
export mma(series float source, simple int period) =>
    if period < 2
        runtime.error("Period must be at least 2")
    var array<float> buffer = array.new_float(math.min(math.max(2, period), 4000), na)
    var int head = 0
    var float sum = 0.0
    var int valid_count = 0
    float oldest = array.get(buffer, head)
    sum := sum + (not na(source) ? source : 0) - (not na(oldest) ? oldest : 0)
    valid_count := valid_count + (not na(source) ? 1 : 0) - (not na(oldest) ? 1 : 0)
    array.set(buffer, head, source)
    head := (head + 1) % array.size(buffer)
    if valid_count <= 0
        source
    else
        float sma = sum / valid_count
        float weighted_sum = 0.0
        int count = 0
        for i = 0 to array.size(buffer) - 1
            float val = array.get(buffer, (head - 1 - i + array.size(buffer)) % array.size(buffer))
            if not na(val)
                weighted_sum += ((valid_count - ((2 * count) + 1)) * 0.5) * val
                count += 1
        sma + (weighted_sum * 6.0) / ((valid_count + 1) * valid_count)
